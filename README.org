# -*- after-save-hook: (org-babel-tangle); before-save-hook: (delete-trailing-whitespace)-*-

#+TITLE: Jonathan Jin's Emacs Configuration
#+AUTHOR: Jonathan Jin
#+PROPERTY: header-args:emacs-lisp :exports code :results none :tangle init.el

#+STARTUP: showall

* Overview

  These are my Emacs configurations. I have been using Emacs since roughly 2012;
  these configurations have been growing since then. They are entirely hand-spun
  -- no reliance on [[https://www.spacemacs.org/][Spacemacs]], [[https://github.com/hlissner/doom-emacs][Doom Emacs]], [[https://prelude.emacsredux.com/][Prelude]], or any other such Emacs
  "framework." This is by no means a knock on those or other frameworks. They
  simply didn't exist (or I was too inexperienced to know about them) when I
  first started using Emacs; and by the time I learned about them, I had already
  become so entrenched and opinionated in my own configurations that it no
  longer made sense to look into any of them.

  In general, I use Emacs very heavily both professionally and personally. In
  particular, I use Emacs for all of my software development. Some notable
  "dependencies" include:

  - The almighty [[magit.vc/][Magit]] for version control;
  - [[https://docs.projectile.mx/projectile/index.html][Projectile]] for project- and repo-level management and development;
  - [[https://emacs-lsp.github.io/lsp-mode/][LSP Mode]] for targeted [[https://microsoft.github.io/language-server-protocol/][language server]] usage.

* Preamble

  #+BEGIN_SRC emacs-lisp
    (require 'cl)
    (add-to-list 'load-path (expand-file-name "~/.emacs.d/elpa"))

    (setq package-archives '(("gnu"           . "http://elpa.gnu.org/packages/")
                              ("melpa-stable" . "http://stable.melpa.org/packages/")
                              ("melpa"        . "http://melpa.org/packages/")
                              ("non-gnu-elpa" . "https://elpa.nongnu.org/nongnu/")
                              ("org"          . "https://orgmode.org/elpa/")))

    (package-initialize)
  #+END_SRC

** Front Matter

*** Straight

    #+BEGIN_SRC emacs-lisp
      (defvar bootstrap-version)
      (let ((bootstrap-file
             (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
            (bootstrap-version 5))
        (unless (file-exists-p bootstrap-file)
          (with-current-buffer
              (url-retrieve-synchronously
               "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
               'silent 'inhibit-cookies)
            (goto-char (point-max))
            (eval-print-last-sexp)))
        (load bootstrap-file nil 'nomessage))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (straight-use-package 'use-package)
      (use-package use-package-ensure-system-package
        :straight t)

      ;; For whatever godawful reason something in here is loading Org prior to the
      ;; (use-package org) block, which causes esoteric load failures, e.g. functions
      ;; missing that should be there.
      ;;
      ;; Remove this whenever you find the root cause.
      (straight-use-package 'org)
    #+END_SRC

*** =use-package=

    The =:if= clause lets us suppress configuration/loading of a given package
    if a provided condition doesn't hold. The following will log such cases
    non-fatally.

    #+BEGIN_SRC emacs-lisp
      (defun jjin/use-package-if-prehook (name _keyword pred rest state)
        (unless pred (error "predicated failed; skipping package")))

      (advice-add 'use-package-handler/:if :before 'jjin/use-package-if-prehook)
    #+END_SRC

*** Baseline

   #+BEGIN_SRC emacs-lisp
     (use-package diminish :straight t)

     (use-package names
       :straight t)

     (use-package system-packages
       :straight t
       :custom
       (system-packages-use-sudo nil)
       :init
       (when (eq system-type 'darwin)
         (setq system-packages-package-manager 'brew)))

     (use-package dash :straight t)

     (setq default-directory "~")
     (setq command-line-default-directory "~")
   #+END_SRC

** Functions

   #+BEGIN_SRC emacs-lisp
     (define-namespace jjin-

     (defvar ext-file-handlers
       `((,(intern "darwin") . (:image
                                ("open")
                                :video
                                ("open" "vlc")))
         (,(intern "gnu/linux") . (:image
                                   ("feh")
                                   :video
                                   ("vlc"))))
       "An alist mapping `system-type' values to priority lists of
       file handlers, e.g. image viewers or video players.")

     (defun load-if-exists (file)
       "Loads file, conditional on its existence; no effect if non-existent."
       (when (file-exists-p file)
         (load-file file)))

     (defun kill-current-buffer ()
       (interactive)
       (kill-buffer (current-buffer)))

     (defun window-toggle-split-direction ()
       "Switch window split from horizontally to vertically, or vice versa.

     i.e. change right window to bottom, or change bottom window to right."
       (interactive)
       (require 'windmove)
       (let ((done))
         (dolist (dirs '((right . down) (down . right)))
           (unless done
             (let* ((win (selected-window))
                    (nextdir (car dirs))
                    (neighbour-dir (cdr dirs))
                    (next-win (windmove-find-other-window nextdir win))
                    (neighbour1 (windmove-find-other-window neighbour-dir win))
                    (neighbour2 (if next-win (with-selected-window next-win
                                               (windmove-find-other-window
                                                neighbour-dir next-win)))))

               (setq done (and (eq neighbour1 neighbour2)
                               (not (eq (minibuffer-window) next-win))))
               (if done
                   (let* ((other-buf (window-buffer next-win)))
                     (delete-window next-win)
                     (if (eq nextdir 'right)
                         (split-window-vertically)
                       (split-window-horizontally))
                     (set-window-buffer (windmove-find-other-window neighbour-dir)
                                        other-buf))))))))

     (defun set-opacity (value)
       "Sets the opacity of the frame window. 0=transparent/100=opaque"
       (interactive "nOpacity Value (0 - 100 opaque): ")
       (set-frame-parameter (selected-frame) 'alpha value))

     ;; credit: https://github.com/abo-abo/hydra/blob/master/hydra-examples.el
     (defun move-splitter-left (arg)
       "Move window splitter left."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'right))
           (shrink-window-horizontally arg)
         (enlarge-window-horizontally arg)))

     ;; credit: https://github.com/abo-abo/hydra/blob/master/hydra-examples.el
     (defun move-splitter-right (arg)
       "Move window splitter right."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'right))
           (enlarge-window-horizontally arg)
         (shrink-window-horizontally arg)))

     ;; credit: https://github.com/abo-abo/hydra/blob/master/hydra-examples.el
     (defun move-splitter-up (arg)
       "Move window splitter up."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'up))
           (enlarge-window arg)
         (shrink-window arg)))

     ;; credit: https://github.com/abo-abo/hydra/blob/master/hydra-examples.el
     (defun move-splitter-down (arg)
       "Move window splitter down."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'up))
           (shrink-window arg)
         (enlarge-window arg)))

     (defun get-current-displays ()
       "Get alist of attributes of displays w/ Emacs buffers."
       (interactive)
       (remove-if
        (lambda (disp)
          (eq nil (cdr (assoc 'frames disp))))
        (display-monitor-attributes-list)))

     (defun fontify-frame (&optional _)
       "Set font and font size dynamically for the given frame."
       (let* ((attrs (frame-monitor-attributes))
              (width (fourth (first attrs)))
              (size 12))
         (when (= width 3840)                 ; external monitor 4k
           (setq size 16))
         ;; FIXME: Integrate w/ jjin/font-priority-list
         ;; FIXME: Need a jjin/get-font-for-frame function that returns the frame's
         ;; currently active font if none in jjin/font-priority-list are found
         (set-frame-font (format "Iosevka %s" size)))))
   #+END_SRC

* General Configurations

  #+BEGIN_SRC emacs-lisp
    (setq tramp-verbose 4)
    (jjin-load-if-exists "~/.secrets.el")

    (setq ring-bell-function 'ignore)

    (setq large-file-warning-threshold nil)

    (setq
      inhibit-startup-screen t
      inhibit-startup-message t
      initial-scratch-message nil
      visible-bell nil
      use-dialog-box nil)

    (setq-default
      indent-tabs-mode nil
      tab-width 4)

    (setq next-line-add-newlines t)

    (setq scroll-step 1
      scroll-conservatively 10000
      scroll-margin 3)

    (setq use-short-answers t)

    (when window-system
      (tool-bar-mode     0)
      (scroll-bar-mode   0)
      (menu-bar-mode     0)
      (line-number-mode  0))

    (blink-cursor-mode 0)

    (global-auto-revert-mode)
    (setq auto-revert-remote-files t)

    (global-hl-line-mode 1)
    (column-number-mode  1)
    (show-paren-mode     1)

    (electric-pair-mode)

    (delete-selection-mode +1)

    (add-hook 'prog-mode-hook 'turn-on-auto-fill)
    (add-hook 'text-mode-hook 'turn-on-auto-fill)

    (fringe-mode '(4 . 0))

    (with-eval-after-load 'dired
      (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file))

    (put 'dired-find-alternate-file 'disabled nil)

    (setq echo-keystrokes 0)

    (use-package image-dired
      :after dash
      :init
      (if-let* ((handlers (alist-get system-type jjin-ext-file-handlers))
                (handler (-first 'executable-find (plist-get handlers :image))))
          (setq image-dired-external-viewer (executable-find handler))))

    (setq term-ansi-default-program (getenv "SHELL"))

    (setq enable-remote-dir-locals t)

    (setq custom-file "~/.emacs-custom.el")
    (load custom-file)

    (use-package midnight
      :init
      (setq clean-buffer-list-delay-general 0.006)) ; 10 minutes

    (setq-default fill-column 80)
  #+END_SRC

** Scratch Org-mode

   I spend more time in Org-mode than I do writing Elisp.

   #+BEGIN_SRC emacs-lisp
     ;; (setq initial-major-mode 'org-mode)
   #+END_SRC

** Appearance

*** Themes

    #+BEGIN_SRC emacs-lisp
      (use-package gotham-theme
        :if window-system
        :disabled t
        :config
        (load-theme 'gotham t))

      (use-package nord-theme
        :if window-system
        :straight t
        :init
        (setq nord-comment-brightness 10)
        :config
        (load-theme 'nord t))

      (use-package kaolin-themes
        :straight t
        :disabled t
        :config
        (load-theme 'kaolin-ocean t))
    #+END_SRC

*** General

    #+BEGIN_SRC emacs-lisp
      (setq-default x-stretch-cursor t)

      (setq custom-safe-themes t)

      (defun jjin/font-installed-p (font-name)
        "Returns t if FONT-NAME is found to be installed; nil otherwise."
        (not (null (x-list-fonts font-name))))

      ;; FIXME: This needs to tap homebrew/cask-fonts first
      ;; FIXME: This currently does not work, since
      ;; `system-packages-package-installed-p' isn't anything more than an alias to
      ;; `executable-find', making this useless.
      ;; (system-packages-ensure "font-iosevka")

      ;; FIXME:
      ;;
      ;; Elements in font-priority-list should consist of:
      ;;   - Font name;
      ;;   - Sizes for: large screens; small screens; etc.
      ;;
      ;; This can allow consuming functions e.g. jjin-fontify-frame to select both the
      ;; name and size based on the display the current frame resides on.
      (defvar jjin/font-priority-list
        '("Iosevka Nerd Font 12" "Iosevka 12" "IBM Plex Mono 12" "Source Code Pro 14" "Terminus (TTF) 16")
        "Priority-sorted list of fonts to attempt to set frame to.")

      ;; TODO: Install font-iosevka

      (if window-system
          (-when-let (font-name (-first 'jjin/font-installed-p jjin/font-priority-list))
            (set-frame-font font-name)))

      ;; (when (functionp 'set-fontset-font)
      ;;   (set-fontset-font "fontset-default"
      ;;                     'unicode
      ;;                     (font-spec :family "DejaVu Sans Mono")))

      (jjin-set-opacity 90)

      (add-hook 'window-size-change-functions #'jjin-fontify-frame)
    #+END_SRC

** Environment-specific

*** Mac

    #+BEGIN_SRC emacs-lisp
       (when (eq system-type 'darwin)
         (add-to-list 'auth-sources 'macos-keychain-internet)

         (setq mac-command-modifier 'meta)
         (setq mac-right-command-modifier 'meta)
         (setq mac-option-modifier 'super)
         (setq mac-right-option-modifier 'super)
         (setq system-uses-terminfo nil))
    #+END_SRC

    =compilation-mode= invokes shell in a non-interactive shell, which means
    that configurations in =.bashrc= do not get surfaced. This can cause
    complications in cases where, for instance, successful compilation is
    predicated on conditions set within a provisioned profile file that I do not
    control. When Bash is started non-interactively, it looks for =BASH_ENV= in
    the environment, expands its value if it appears there, and uses the
    expanded value as the name of a file to read and execute. As such, we set
    that environment value to our startup file here.

    #+begin_src emacs-lisp
      (when (eq system-type 'darwin) (setenv "BASH_ENV" "$HOME/.bashrc"))
    #+end_src


** Server

   Make sure =EDITOR= and/or =VISUAL= is/are set to =emacsclient=.

   #+BEGIN_SRC emacs-lisp
     (use-package server
       :config
       (unless (server-running-p) (server-start)))
   #+END_SRC

** Nested .dir-locals.el

   #+begin_src emacs-lisp
     (use-package nested-dir-local
       :straight (:repo "git@github.com:jinnovation/nested-dir-locals.el.git"))
   #+end_src

** Window Configurations

   #+begin_src emacs-lisp
     (use-package eyebrowse
       :straight t
       :custom
       (eyebrowse-new-workspace t)
       :config
       (eyebrowse-mode 1))
     ;; FIXME: Add eyebrowse switch window config bindings to the window hydra

     (defvar jjin/help-modes '(helpful-mode
                               help-mode
                               Man-mode
                               woman-mode
                               Info-mode
                               godoc-mode))

     (defun jjin/help-buffer-p (buf &optional act)
       "Check if BUF is a 'help' buffer.

     ACT is a buffer action that enables use in
     `display-buffer-alist'."
       (member (with-current-buffer buf major-mode) jjin/help-modes))

     (add-to-list 'display-buffer-alist
                  `(jjin/help-buffer-p
                    (display-buffer--maybe-same-window
                     display-buffer-reuse-window
                     display-buffer-reuse-mode-window)
                    (mode . ,jjin/help-modes)
                    (inhibit-same-window . nil)))

     ;; FIXME: This doesn't play nicely w/ M-x mu4e
     (add-to-list 'display-buffer-alist
                  '((lambda (buf act) (equal (with-current-buffer buf major-mode) 'mu4e-headers-mode))
                    (display-buffer--maybe-same-window
                     display-buffer-reuse-window
                     display-buffer-reuse-mode-window)

                    (mode . mu4e-headers-mode)
                    (inhibit-same-window . nil)
                    )
                  )
   #+end_src

** Compilation mode

   #+begin_src emacs-lisp
     (add-hook 'compilation-filter-hook 'ansi-color-compilation-filter)
   #+end_src

* Keys

** Personal maps

   #+BEGIN_SRC emacs-lisp
     (define-prefix-command 'jjin-vc-map)
     (bind-key "C-c v" 'jjin-vc-map)

     (define-prefix-command 'jjin-comment-map)
     (bind-key "C-c c" 'jjin-comment-map)

     (define-prefix-command 'jjin-term-map)
     (bind-key "C-c t" 'jjin-term-map)

     (define-prefix-command 'jjin-buffer-map)
     (bind-key "C-c b" 'jjin-buffer-map)
   #+END_SRC

** Keybindings

   #+BEGIN_SRC emacs-lisp
     (bind-keys :map global-map
                ("C-x k"              . jjin-kill-current-buffer)
                ("C-x m"              . execute-extended-command)
                ("RET"                . newline-and-indent))

     (unbind-key "<menu>")
     (unbind-key "M-`")
     (unbind-key "C-c C-w")
     (unbind-key "C-x C-n")      ; set-goal-column
     (unbind-key "s-t")          ; ns-popup-font-panel
     (unbind-key "s-w")          ; delete-frame

     (unbind-key "<f10>")
     (unbind-key "<f11>")
     (unbind-key "M-<f10>")
     (unbind-key "<escape> <f10>")

     (bind-keys :map jjin-buffer-map
                ("r" . rename-buffer))

     (bind-keys :map global-map
                ("<s-backspace>" . backward-kill-word)
                ("s-s" . save-buffer)
                ("s-b" . switch-to-buffer)
                ("s-`" . recompile))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package hydra
       :commands defhydra
       :straight t)

     (use-package pretty-hydra
       :straight t
       :config
       (pretty-hydra-define jjin-hydra-window
         (:title (with-octicon "browser" "Windows" 1 -0.05))

         ("Move"
          (("h" windmove-left "move left")
           ("l" windmove-right "move right")
           ("j" windmove-down "move down")
           ("k" windmove-up "move up"))
          "Split"
          (("H" jjin-move-splitter-left "move splitter left")
           ("L" jjin-move-splitter-right "move splitter right")
           ("J" jjin-move-splitter-down "move splitter down")
           ("K" jjin-move-splitter-up "move splitter up")
           ("|" jjin-window-toggle-split-direction "toggle split")
           ("s" split-window-below "split window (below)")
           ("v" split-window-right "split window (right)"))
          "Other"
          (("q" delete-window "delete window")
           ("Q" kill-buffer-and-window "kill buffer, delete window")
           ("b" balance-windows "balance")
           (";" ace-window "select window" :exit t))))

       (bind-key "C-c w" 'jjin-hydra-window/body))

     (use-package major-mode-hydra
       :straight t
       :bind
       ("s-SPC" . major-mode-hydra))
   #+END_SRC

* Development Environments

** LSP

   The [[https://microsoft.github.io/language-server-protocol/][Language Server Protocol (LSP)]] provides an interchange protocol to allow
   editor-agnostic language functionality.

   #+begin_src emacs-lisp
     (use-package lsp-mode
        :straight t
        :hook ((python-mode . lsp-deferred)
               (go-mode . lsp-deferred))
               ;; (terraform-mode . lsp-deferred)
               ;; (yaml-mode . lsp-deferred))
        ;; TODO:
        ;; For Python, would like the following installed:
        ;;   - python-lsp-server
        ;;   - python-lsp-black
        ;;   - pylsp-mypy
        ;;   - pyls-isort
        :custom
        (lsp-ui-sideline-enable nil)         ; Disable until the weird text
                                             ; overflow issue is fixed
        (lsp-signature-render-documentation nil)
        (lsp-pyls-configuration-sources ["flake8"])
        (lsp-pyls-plugins-pycodestyle-enabled nil)
        (lsp-pylsp-server-command '("pylsp"))
        (lsp-pyls-server-command '("pylsp"))
        (lsp-enable-snippet nil)
        (lsp-log-io t)
        (lsp-document-sync-method nil)
        (lsp-print-performance t)
        (lsp-before-save-edits nil)
        (lsp-signature-render-documentation t)
        (lsp-pyls-plugins-pydocstyle-enabled t)
        (lsp-pyls-plugins-pyflakes-enabled nil)
        (lsp-pyls-plugins-flake8-enabled t)
        (lsp-pyls-plugins-pydocstyle-convention "pep257")
        (lsp-pyls-plugins-mccabe-enabled nil)
        (lsp-go-codelenses nil)
        (lsp-go-use-gofumpt t)
        :init
        ;; (setq lsp-document-sync-method 'lsp--sync-incremental)
        (add-hook 'hack-local-variables-hook
                  (lambda () (when (derived-mode-p 'python-mode) (lsp))))
        :config
        (when (-contains? (lsp-session-folders (lsp-session)) (f-expand "~"))
          (warn "LSP workspace folders list contains home dir; this can be problematic, consider removing."))

        (lsp-register-custom-settings '(("gopls.completeUnimported" t t)
                                        ("gopls.staticcheck" t t)
                                        ("pyls.plugins.pyls_mypy.enabled" t t)
                                        ("pyls.plugins.pyls_mypy.live_mode" nil t)))

        (lsp-register-client
         (make-lsp-client :new-connection (lsp-stdio-connection '("terraform-ls"
                                                                  "serve"))
                          :major-modes '(terraform-mode)
                          :server-id 'terraform-ls))

        ;; Sets up server configuration for use over TRAMP.
        ;;
        ;; FIXME: This is copied wholesale from the default lsp-mode configuration for
        ;; pyls. Find a way to source these params directly from that client itself.
        (lsp-register-client
         (make-lsp-client :new-connection (lsp-tramp-connection "pyls")
                          :major-modes '(python-mode cython-mode)
                          :remote? t
                          :library-folders-fn (lambda (_workspace) lsp-clients-python-library-directories)
                          :initialized-fn (lambda (workspace)
                                            (with-lsp-workspace workspace
                                                                (lsp--set-configuration (lsp-configuration-section "pyls"))))
                          :server-id 'pyls-remote))

        ;; FIXME: Oncen gopackagesdriver is available, set up here to cooperate w/
        ;; Bazel projects.
        (defun lsp-go-install-save-hooks ()
          (add-hook 'before-save-hook #'lsp-format-buffer t t)
          (add-hook 'before-save-hook #'lsp-organize-imports t t))
        (add-hook 'go-mode-hook #'lsp-go-install-save-hooks))
   #+end_src

** Bazel

   #+begin_src emacs-lisp
     (use-package bazel-mode
       :straight (emacs-bazel-mode :type git :host github :repo "bazelbuild/emacs-bazel-mode"))
     (if (file-exists-p "~/workspace/bazel-transient")
     (use-package bazel-transient
       :after (bazel-mode transient)
       :straight (:local-repo "~/workspace/bazel-transient")
       :custom
       (bazel-transient-enable-caching t)
       (bazel-transient-completion-system 'ivy)))
   #+end_src

** C/C++

   #+BEGIN_SRC emacs-lisp
     (setq c-block-comment-prefix "* ")

     ;; (defvaralias 'c-basic-offset 'tab-width)

     (c-set-offset 'arglist-intro '+)
     (c-set-offset 'arglist-close 0)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package irony
       :disabled t
       :commands irony-mode
       :init
       (add-hook 'c-mode-hook 'irony-mode)
       (add-hook 'c++-mode-hook 'irony-mode)
       :config
       (use-package flycheck-irony
         :config
         (add-hook 'flycheck-mode-hook 'flycheck-irony-setup)))

     (use-package company-irony
       :disabled t
       :config
       (add-to-list 'company-backends 'company-irony))

     (use-package clang-format
       :disabled t
       :config
       (add-to-list 'auto-mode-alist '("\\.clang-format$" . yaml-mode)))
   #+END_SRC

*** CUDA

    #+begin_src emacs-lisp
      (use-package cuda-mode
        :straight t)
    #+end_src

** Go

   #+BEGIN_SRC emacs-lisp
     (use-package go-mode
       :mode "\\.go$"
       :after exec-path-from-shell
       :straight t
       :disabled t                           ; using LSP
       :bind (:map go-mode-map
                   ("C-c J" . (lambda (point) (interactive "d") (godef-jump point t))))
       :config
       (when (executable-find "goimports")
         (setq gofmt-command "goimports"))
       (add-hook 'before-save-hook 'gofmt-before-save))

     (use-package company-go
       :after go
       :disabled t)

     (use-package go-guru
       :after go
       :straight t)

     (use-package lsp-ivy
       :straight t
       :after (ivy lsp-mode))

     (use-package lsp-ui
       :straight t
       :after lsp-mode
       :custom
       (lsp-ui-doc-enable nil "doc display on hover uses posframes (don't work well w/ macos fullscreen)")
       (lsp-ui-sideline-show-hover t))
   #+END_SRC

** Lisp

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("emacs$" . emacs-lisp-mode))
     (add-to-list 'auto-mode-alist '("Cask" . emacs-lisp-mode))
   #+END_SRC

** Javascript

   #+BEGIN_SRC emacs-lisp
     (defvaralias 'js-indent-level 'tab-width)

     (use-package js2-mode
       :mode (("\\.js$" . js2-mode)
              ("\\.jsx$" . js2-jsx-mode))
       :straight t)

     (use-package json-mode
       :straight t)
   #+END_SRC

** LaTeX

   #+BEGIN_SRC emacs-lisp
     ;; sets latex-mode to compile w/ pdflatex by default
     (setq TeX-PDF-mode t
         TeX-parse-self t
         TeX-newline-function 'reindent-then-newline-and-indent)

     (eval-after-load "tex"
         '(setcdr (assoc "LaTeX" TeX-command-list)
              '("%`%l%(mode) -shell-escape%' %t"
                   TeX-run-TeX nil (latex-mode doctex-mode) :help "Run LaTeX")))

     ;; latex-mode-specific hooks (because latex-mode is not derived from prog-mode)
     (add-hook 'LaTeX-mode-hook
         (lambda ()
             (TeX-fold-mode 1)
             (auto-fill-mode)
             (add-to-list 'TeX-command-list '("XeLaTeX" "%`xelatex%(mode)%' %t"
                                                 TeX-run-TeX nil t))))
   #+END_SRC

** Shell

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("zshrc$" . sh-mode))
     (add-to-list 'auto-mode-alist '("\\.zsh$" . sh-mode))
     (add-to-list 'auto-mode-alist '("\\.bats$" . sh-mode))
   #+END_SRC

** Graphing

   #+begin_src emacs-lisp
     (use-package graphviz-dot-mode
       :straight t)
   #+end_src

   #+begin_src emacs-lisp
     (use-package mermaid-mode
       :straight t)
   #+end_src

** Haskell

   #+BEGIN_SRC emacs-lisp
     (use-package haskell-mode
       :disabled t
       :config
       (add-hook 'haskell-mode-hook 'turn-on-haskell-indent))
   #+END_SRC

** SQL

   #+BEGIN_SRC emacs-lisp
     (add-hook 'sql-interactive-mode-hook
               (lambda ()
                 (toggle-truncate-lines t)))
   #+END_SRC

** Protobuf

   #+begin_src emacs-lisp
     (use-package protobuf-mode
       :straight t)
   #+end_src
** Octave

   #+BEGIN_SRC emacs-lisp
     (use-package octave
       :disabled t
       :mode ("\\.m$" . octave-mode)
       :interpreter ("octave" . octave-mode)
       :config
       (with-eval-after-load 'evil
           (progn
             (add-to-list 'evil-emacs-state-modes 'octave-help-mode)
             (add-to-list 'evil-emacs-state-modes 'inferior-octave-mode)))

       (setq inferior-octave-program "octave-cli")
       (setq inferior-octave-prompt ">> ")
       (setq inferior-octave-dynamic-complete-functions '(comint-filename-completion))

       (setq inferior-octave-startup-args '("-i" "--line-editing" "-q" "--traditional")))
   #+END_SRC

** Matlab

   #+BEGIN_SRC emacs-lisp
     (use-package matlab
       :disabled t
       :init
       (setq matlab-shell-command-switches '("-nodesktop")))
   #+END_SRC

** Nix

#+begin_src emacs-lisp
  (use-package nix-mode
    :straight t)
#+end_src

** Python

   #+BEGIN_SRC emacs-lisp
     (setq python-fill-docstring-style 'pep-257)

     (setq python-indent-def-block-scale 1)

     (use-package pyvenv
       :straight t)

     (use-package virtualenvwrapper
       :straight t
       :disabled t
       :config
       (venv-initialize-eshell))

     (use-package anaconda-mode
       :straight t
       :disabled t
       :config
       (add-hook 'python-mode-hook 'anaconda-mode))

     (use-package company-anaconda
       :after (anaconda-mode company)
       :straight t
       :config
       (add-to-list 'company-backends 'company-anaconda))

     (use-package elpy
       :disabled t                           ; using LSP
       :straight t
       :init
       (setq elpy-modules '(elpy-module-company
                            elpy-module-eldoc
                            elpy-module-flymake
                            elpy-module-pyvenv
                            elpy-module-yasnippet
                            elpy-module-sane-defaults)))
   #+END_SRC

** Emacs Lisp

   #+BEGIN_SRC emacs-lisp
     (use-package elisp-mode
       :bind (("C-c C-f" . find-function)
              ("C-c C-v" . find-variable)))
   #+END_SRC

*** Testing

    #+begin_src emacs-lisp
      (use-package buttercup
        :straight t)
    #+end_src

** Markdown

   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :straight t
       :mode "\\.md$"
       :bind (:map markdown-mode-map
                   ("M-]" . markdown-demote)
                   ("M-[" . markdown-promote))
       :init
       (setq markdown-asymmetric-header t)
       :config
       (add-hook 'markdown-mode-hook 'auto-fill-mode))

     (use-package markdown-mode+
       :straight t
       :after markdown-mode)
   #+END_SRC

** reStructuredText

   #+begin_src emacs-lisp
     (use-package rst
       :config
       (set-face-attribute 'rst-reference
                           nil
                           :foreground
                           (face-attribute 'font-lock-type-face :foreground)))
   #+end_src

** YAML

   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode
       :straight t
       :mode "\\.yaml$"
       :hook
       (yaml-mode . (lambda ()
                      (unless (not (require 'highlight-indent-guides nil 'noerror))
                        (highlight-indent-guides-mode)))))
   #+END_SRC

** Rust

   #+begin_src emacs-lisp
     (use-package rust-mode
       :disabled t
       :straight t
       :config
       (add-to-list 'exec-path "~/.cargo/bin/")
       (setq rust-format-on-save t))
   #+end_src

** Scala

   #+begin_src emacs-lisp
     (use-package scala-mode
       ;; :ensure-system-package
       ;; ((scala . scala)
       ;;  (sbt . sbt))
       :straight t)
   #+end_src

** Jinja2

   #+begin_src emacs-lisp
     (use-package jinja2-mode
       :straight t)
   #+end_src

* General Packages

** =ace-link=

   #+BEGIN_SRC emacs-lisp
     (use-package ace-link
       :straight t
       :after org ;; fn ace-link-org loads org-mode
       :commands (ace-link-eww ace-link-setup-default)
       :init (ace-link-setup-default))
   #+END_SRC

** =ace-window=

   #+BEGIN_SRC emacs-lisp
     (use-package ace-window
       :commands ace-window
       :straight t
       :init
       (setq aw-keys '(?a ?r ?s ?t ?q ?w ?f ?p))

       :config
       ;; technically should be able to use mu4e~update-name but for whatever reason
       ;; the mu4e update index function uses the hardcoded string w/ space padding.
       (add-to-list 'aw-ignored-buffers " *mu4e-update*"))
   #+END_SRC

** =browse-url=

   #+BEGIN_SRC emacs-lisp
     (use-package browse-url
       :config)
   #+END_SRC

** [[https://github.com/wandersoncferreira/code-review][code-review]]

   #+begin_src emacs-lisp
     (use-package code-review
       :straight t
       :custom
       (code-review-github-host "ghe.spotify.net/api/v3")
       (code-review-github-graphql-host "ghe.spotify.net/api")
       (code-review-github-base-url "ghe.spotify.net"))
   #+end_src

** =conf-mode=

   #+BEGIN_SRC emacs-lisp
     (use-package conf-mode
       :mode
       (;; systemd
         ("\\.service\\'"     . conf-unix-mode)
         ("\\.timer\\'"      . conf-unix-mode)
         ("\\.target\\'"     . conf-unix-mode)
         ("\\.mount\\'"      . conf-unix-mode)
         ("\\.automount\\'"  . conf-unix-mode)
         ("\\.slice\\'"      . conf-unix-mode)
         ("\\.socket\\'"     . conf-unix-mode)
         ("\\.path\\'"       . conf-unix-mode)

         ;; general
         ("conf\\(ig\\)?$"   . conf-mode)
         ("rc\\(_local\\)?$" . conf-mode)))
   #+END_SRC

** =company=

   #+BEGIN_SRC emacs-lisp
     (use-package company
       :defines company-backends
       :diminish company-mode
       :straight t
       :custom
       (company-dabbrev-downcase nil)
       :config
       (add-hook 'after-init-hook 'global-company-mode)
       (setq company-idle-delay 0.1))
   #+END_SRC

** =dired=

   #+BEGIN_SRC emacs-lisp
     (setq dired-listing-switches "-alh")

     (use-package dired-open
       :straight t
       :after dash
       :init
       (if-let* ((handler-vid (-first 'executable-find
                                      (plist-get
                                       (alist-get system-type jjin-ext-file-handlers)
                                       :video)))
                 (path (executable-find handler-vid)))
           (setq dired-open-extensions `(("mp4" . ,(executable-find handler-vid))
                                         ("avi" . ,(executable-find handler-vid))))))
   #+END_SRC

** =doc-view-mode=

   #+BEGIN_SRC emacs-lisp
     (use-package doc-view
       :init
       (setq doc-view-resolution 200))
   #+END_SRC

** Docker

   #+begin_src emacs-lisp
     (use-package docker
       :straight t)

     (use-package dockerfile-mode
       :straight t)
   #+end_src

** =ediff=

   #+BEGIN_SRC emacs-lisp
     (use-package ediff
       :init
       (setq ediff-window-setup-function 'ediff-setup-windows-plain))
   #+END_SRC

** =exec-path-from-shell=

   #+BEGIN_SRC emacs-lisp
     (use-package exec-path-from-shell
       :straight t
       :custom
       (exec-path-from-shell-variables '("PATH"
                                         "MANPATH"
                                         "GOPATH"
                                         "GOROOT"
                                         "GO111MODULE"
                                         "JENKINS_USER"
                                         "JENKINS_API_TOKEN"))
       ;; (exec-path-from-shell-shell-name "zsh")
       (exec-path-from-shell-shell-name shell-file-name)
       :config
       (exec-path-from-shell-initialize))
    #+END_SRC

** Elfeed

   #+BEGIN_SRC emacs-lisp
     (use-package elfeed
       :disabled t
       :straight t
       :commands elfeed
       :bind (:map elfeed-search-mode-map
              ("<SPC>" . next-line)
              ("U" . elfeed-unjam)
              :map elfeed-show-mode-map
              ("S-<SPC>" . scroll-down-command))

       :init
       (setq elfeed-use-curl t)
       (setq elfeed-log-level 'info)

       (defun jjin/elfeed-read-feed ()
         (interactive)
         (completing-read
          "Feed: "
          (delete-dups (-map 'elfeed-feed-title (hash-table-values elfeed-db-feeds)))))

       ;; (with-eval-after-load 'ivy-rich
       ;;   (plist-put ivy-rich-display-transformers-list
       ;;              'jjin/elfeed-read-feed
       ;;              '(:columns
       ;;                ((ivy-rich-candidate (:width 40))
       ;;                 (elfeed-feed-autotags (:face font-lock-doc-face))))))


       :config
       (with-eval-after-load 'evil
         (add-to-list 'evil-emacs-state-modes 'elfeed-search-mode)
         (add-to-list 'evil-emacs-state-modes 'elfeed-show-mode))

       (set-face-attribute 'elfeed-search-feed-face
                           nil
                           :foreground (face-attribute 'warning :foreground))

       (set-face-attribute 'elfeed-search-tag-face
                           nil
                           :foreground (face-attribute 'success :foreground))

       (set-face-attribute 'elfeed-search-unread-title-face
                           nil
                           :weight 'normal
                           :foreground (face-attribute 'default :foreground))

       (set-face-attribute 'elfeed-search-title-face
                           nil
                           :foreground (face-attribute 'font-lock-comment-face :foreground)))

     (use-package elfeed-protocol
       :disabled t
       :after elfeed
       :straight (:host github
                  :type git
                  :repo "fasheng/elfeed-protocol"
                  :fork (:host github :repo "jinnovation/elfeed-protocol" :branch "master"))

       :if (-all-p 'boundp '(jjin/secret/ttrss-domain
                             jjin/secret/ttrss-username
                             jjin/secret/ttrss-pass))
       :init
       (setq elfeed-feeds
             (list (format "ttrss+http://%s:%s@%s" jjin/secret/ttrss-username jjin/secret/ttrss-pass jjin/secret/ttrss-domain)))

       (setq elfeed-protocol-ttrss-categories-as-tags t)

       :config
       (elfeed-protocol-enable))

     (use-package elfeed-org
       :straight t
       :disabled t
       :after elfeed
       :config
       (setq rmh-elfeed-org-files '("~/.emacs.d/feeds.org"))
       (elfeed-org))

     (use-package elfeed-score
       :disabled t
       :straight t
       :after elfeed
       :config
       (elfeed-score-enable nil)
       (setq elfeed-search-print-entry-function #'elfeed-score-print-entry)
       (define-key elfeed-search-mode-map "=" elfeed-score-map))
   #+END_SRC

** Eshell

   #+BEGIN_SRC emacs-lisp
     ;; From: https://www.emacswiki.org/emacs/EshellPrompt
     (defun shortened-path (path max-len)
           "Return a modified version of `path', replacing some components
           with single characters starting from the left to try and get
           the path down to `max-len'"
           (let* ((components (split-string (abbreviate-file-name path) "/"))
                  (len (+ (1- (length components))
                          (reduce '+ components :key 'length)))
                  (str ""))
             (while (and (> len max-len)
                         (cdr components))
               (setq str (concat str (if (= 0 (length (car components)))
                                         "/"
                                       (string (elt (car components) 0) ?/)))
                     len (- len (1- (length (car components))))
                     components (cdr components)))
             (concat str (reduce (lambda (a b) (concat a "/" b)) components))))

     (use-package eshell
       :init
       (add-hook 'eshell-mode-hook 'goto-address-mode)
       (setq eshell-rc-script (concat user-emacs-directory "eshell/profile"))
       (setq eshell-modify-global-environment t)
       (setq eshell-banner-message "")

       :custom
       (eshell-visual-options '(("bazel" "--curses=yes")))

       :config
       (unless (file-exists-p (concat user-emacs-directory "eshell"))
         (make-directory (concat user-emacs-directory "eshell")))
       (with-eval-after-load 'evil
         (delete 'eshell-mode evil-insert-state-modes)
         (add-to-list 'evil-emacs-state-modes 'eshell-mode))

       ;; (with-eval-after-load 'counsel
         ;; (bind-key "M-r" 'counsel-esh-history eshell-mode-map))

       (bind-keys :map jjin-term-map
                  ("e" . eshell))

       (defun eshell/la (&rest args)
         (eshell/ls "--almost-all" "-l" args))

       (defun eshell/ff (&rest args)
         ;; (let ((f-open  (completing-read "File: " (eshell/ls))))
         ;;   (print f-open))
         (apply #'find-file args))

       (defun jjin/interpreter-match-git-show (cmd args)
           (and (string= cmd "git") (string= (car args) "diff")))

       (with-eval-after-load 'magit
         (add-to-list 'eshell-interpreter-alist
                      '(jjin/interpreter-match-git-show
                        .
                        (lambda (&rest args) (magit-show-commit (car (last args))))))
         (setq eshell-prompt-function
               (lambda ()
                 (concat
                  (propertize "┌─[" 'face 'font-lock-string-face)
                  (propertize (user-login-name) 'face 'font-lock-function-name-face)
                  (when (magit-git-repo-p default-directory)
                    (concat
                     (propertize "@" 'face 'font-lock-string-face)
                     (when-let ((b (magit-get-current-branch)))
                       (propertize b 'face `(:foreground "yellow")))
                     (when (magit-anything-modified-p)
                       (propertize "*" 'face `(:foreground "yellow")))))
                  (propertize "]──[" 'face 'font-lock-string-face)
                  (propertize (format-time-string "%H:%M:%S" (current-time)) 'face 'font-lock-keyword-face)
                  (propertize "]──[" 'face 'font-lock-string-face)
                  (propertize (shortened-path (eshell/pwd) 40) 'face `(:foreground "white"))
                  (propertize "]\n" 'face 'font-lock-string-face)
                  (propertize "└─>" 'face 'font-lock-string-face)
                  (propertize (if (= (user-uid) 0) " #" " $") 'face 'font-lock-string-face)
                  " "
                  )))))
   #+END_SRC

*** Initialization file

    #+BEGIN_SRC emacs-lisp :tangle eshell/profile
      (setenv "EDITOR" "emacsclient")
    #+END_SRC

** vterm

   #+begin_src emacs-lisp
     (use-package vterm
       ;; :ensure-system-package cmake
       :straight t
       :bind (:map global-map
                   ("s-v" . vterm))
       :hook
       (vterm-mode . goto-address-mode)
       :custom
       (vterm-shell "/bin/zsh")
       (vterm-kill-buffer-on-exit t)
       :config
       (with-eval-after-load 'evil
         (add-to-list 'evil-emacs-state-modes 'vterm-mode)))
   #+end_src

** =ess=

   #+BEGIN_SRC emacs-lisp
     (use-package ess-site
       :disabled t
       :ensure ess
       :commands (inferior-ess-mode ess-help-mode)
       :init
       (setq inferior-R-args "--quiet")

       :config
       (with-eval-after-load 'evil
           (progn
             (add-to-list 'evil-emacs-state-modes 'inferior-ess-mode)
             (add-to-list 'evil-emacs-state-modes 'ess-help-mode)))
       (bind-key "C-c C-w" nil inferior-ess-mode-map))
   #+END_SRC

** Evil (base + extras)

   #+BEGIN_SRC emacs-lisp
     (use-package evil
       :straight t
       :defines evil-normal-state-map
       :init
       (setq evil-esc-delay 0)

       :config
       (mapc (lambda (m) (add-to-list 'evil-emacs-state-modes m t))
         '(eshell-mode
            calendar-mode

            finder-mode
            info-mode

            eww-mode
            eww-bookmark-mode

            dired-mode
            image-mode
            image-dired-thumbnail-mode
            image-dired-display-image-mode

            git-rebase-mode

            help-mode

            sql-interactive-mode
            org-capture-mode))
       ;; FIXME: what's the diff between set-initial-state and adding to list directly?
       (evil-set-initial-state 'term-mode 'emacs)

       (bind-keys :map evil-emacs-state-map
         ("<escape>" . evil-execute-in-normal-state))

       (evil-mode 1))

     (use-package evil-numbers
       :after evil
       :straight t
       :config
       (bind-keys :map evil-normal-state-map
                  ("C-a"   . evil-numbers/inc-at-pt)
                  ("C-c -" . evil-numbers/dec-at-pt)))

     (use-package evil-search-highlight-persist
       :after evil
       :straight t
       :config
       (bind-key "C-l" 'evil-search-highlight-persist-remove-all
                 evil-normal-state-map)
       (global-evil-search-highlight-persist t)

       (set-face-attribute
        'evil-search-highlight-persist-highlight-face
        nil
        :background (face-attribute 'match :background)))

     (use-package evil-surround
       :after evil
       :straight t
       :config
       (global-evil-surround-mode 1))

     (use-package evil-nerd-commenter
       :after evil
       :straight t
       :config
       (bind-keys :map jjin-comment-map
                  ("i" . evilnc-comment-or-uncomment-lines)
                  ("l" . evilnc-quick-comment-or-uncomment-to-the-line)
                  ("c" . evilnc-copy-and-comment-lines)
                  ("p" . evilnc-comment-or-uncomment-paragraphs)
                  ("v" . evilnc-toggle-invert-comment-line-by-line)))

   #+END_SRC

** =fill-column-indicator=

   #+BEGIN_SRC emacs-lisp
     (use-package fill-column-indicator
       :commands turn-on-fci-mode
       :straight t
       :disabled t
       :init
       (add-hook 'prog-mode-hook 'turn-on-fci-mode)
       (add-hook 'text-mode-hook 'turn-on-fci-mode)
       (setq fci-rule-color (face-attribute 'highlight :background)))
   #+END_SRC

** =flycheck=

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :straight t
       :defines flycheck-mode-hook
       :config
       (add-hook 'after-init-hook #'global-flycheck-mode))
   #+END_SRC

** Git

   #+BEGIN_SRC emacs-lisp
     (bind-keys :map jjin-vc-map
                ("g" . vc-git-grep))

     (setq vc-handled-backends '(git))
   #+END_SRC

*** =git-commit-mode=

    #+BEGIN_SRC emacs-lisp
      (use-package git-commit-mode
        :commands git-commit-mode)
    #+END_SRC

*** =gitconfig-mode=
    #+BEGIN_SRC emacs-lisp
      (use-package gitconfig-mode
        :disabled t
        :straight t
        :mode "gitconfig")
    #+END_SRC

*** =gitignore-mode=

    #+BEGIN_SRC emacs-lisp
      (use-package gitignore-mode
        :disabled t
        :straight t
        :mode "gitignore")
    #+END_SRC

*** Magit

    Merge commits can sometimes be massive -- particularly in monorepo
    environments. Since showing the diff during commit in such scenarios is of
    questionable utility, we suppress its behavior with the following advice.

    #+begin_src emacs-lisp
      (defun jjin/do-if-merge-not-in-progress (oldfun)
        "Displays the diff during commit only in cases where a merge is
        not in progress."
        (when (not (magit-merge-in-progress-p)) (funcall oldfun)))

      (defun jjin/magit-fetch-from-origin-master ()
        (interactive)
        (magit-git-fetch "origin" "master"))

      (defun jjin/magit-checkout-previous-branch ()
        (interactive)
        (if-let ((p (magit-get-previous-branch)))
            (magit-checkout p)
          (error "No previous branch")))
    #+end_src

    #+BEGIN_SRC emacs-lisp
      ;; TODO: Magit has migrated to using transient, so all commented sections will
      ;; eventually need to be updated or removed.

      (use-package transient
        :straight t
        :init
        (setq transient-show-common-commands nil))

      (use-package git-modes
        :straight t)

      (use-package magit
        :straight t
        :hook
        (magit-revision-mode . goto-address-mode)
        :init
        ;; On status buffer init, jump to either unstaged changes or staged changes,
        ;; if present
        (setq magit-status-initial-section
              '(((unstaged) (status))
                ((staged) (status))))

        (add-to-list
         'safe-local-variable-values
         '(magit-status-headers-hook . (list
                                        magit-insert-error-header
                                        magit-insert-diff-filter-header
                                        magit-insert-head-branch-header
                                        magit-insert-upstream-branch-header
                                        magit-insert-push-branch-header)))

        (setq magit-log-arguments '("--graph"
                                    "--decorate"
                                    "--color"))

        (setq magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)

        (defun jjin/magit-status-at (dir)
          "Open Magit status buffer for project at root DIR."
          (magit-status dir))
        :bind (:map jjin-vc-map
                    ("!" . magit-git-command-topdir)
                    ("C" . magit-branch-and-checkout)
                    ("F" . magit-pull)
                    ("P" . magit-push)
                    ("b" . magit-blame)
                    ("c" . magit-checkout)
                    ("d" . magit-diff)
                    ("f" . magit-fetch)
                    ("l" . magit-log)
                    ("m" . magit-merge)
                    ("v" . magit-status)
                    ("z" . magit-stash)
                    :map magit-mode-map
                    ("X" . magit-reset-hard))

        :commands (magit-status)

        :config
        (with-eval-after-load 'git-rebase
          (bind-keys :map git-rebase-mode-map ("u" . git-rebase-undo)))

        ;; removes 1.4.0 warning in arguably cleaner way
        (remove-hook 'after-init-hook 'magit-maybe-show-setup-instructions)

        (defadvice magit-blame-mode (after switch-to-emacs-state activate)
          (if magit-blame-mode
              (evil-emacs-state 1)
            (evil-normal-state 1)))

        (with-eval-after-load 'evil
          (add-to-list 'evil-emacs-state-modes 'magit-popup-mode))

        (transient-append-suffix 'magit-commit 'magit-commit:--reuse-message
          '("-m"
            "Attach message"
            "--message="
            :prompt "Message"
            :reader magit-read-string))

        (defun jjin/magit-diff-upstream (&optional args files)
          (interactive (magit-diff-arguments))
          ;; FIXME: Use of HEAD here causes the diff buffer to reload when switching
          ;; branches. Fetch the explicit branch ref to keep the original diff
          ;; resilient.
          (magit-diff-range "@{u}..HEAD" args))

        (transient-insert-suffix 'magit-diff 'magit-show-commit
          '("U" "Diff upstream" jjin/magit-diff-upstream))

        (defun jjin/magit-find-file-from-upstream (file)
          "Same behavior as `magit-find-file', but specifically for the
      upstream branch."
          (interactive
           (list (magit-read-file-from-rev (magit-get-upstream-branch) "Find file")))
          (magit-find-file (magit-get-upstream-branch) file))

        (transient-append-suffix 'magit-fetch 'magit-fetch-all
          '("U" "origin/master" jjin/magit-fetch-from-origin-master))

        ;; TODO: The below advice causes odd conflicts when used w/ `arc diff' and
        ;; emacsclient. Resolve before re-introducing.

        ;; Suppress diff display when the commit in question is a merge
        ;; (advice-add 'magit-commit-diff :before-until 'magit-merge-in-progress-p)
        )

        ;; (plist-put magit-merge-popup :actions (cons "Actions" (plist-get magit-merge-popup :actions)))
        ;; (plist-put magit-merge-popup
        ;;            :actions
        ;;            (cons '(?U "Upstream" (lambda (ignored &optional args)
        ;;                                    (interactive (magit-diff-arguments))
        ;;                                    (magit-merge "@{u}" args)))
        ;;                  (plist-get magit-merge-popup :actions)))

        ;; (plist-put
        ;;  magit-merge-popup
        ;;  :actions
        ;;  (cons
        ;;   (lambda ()
        ;;     (concat (propertize "Merge into " 'face 'magit-popup-heading)
        ;;             (propertize (or (magit-get-current-branch) "HEAD") 'face 'magit-branch-local)
        ;;             (propertize " from" 'face 'magit-popup-heading)))
        ;;   (plist-get magit-merge-popup :actions)))

        ;; (magit-define-popup-action 'magit-branch-popup
        ;;   ?P
        ;;   (lambda ()
        ;;     (if-let ((p (magit-get-previous-branch)))
        ;;         "Checkout previous branch"
        ;;       "No previous branch"))
        ;;   'jjin/magit-checkout-previous-branch))

      (use-package forge
        :straight t
        :after (magit transient)
        :custom
        (forge-owned-accounts "jjin")
        :config
        (add-to-list 'forge-alist '("ghe.spotify.net" "ghe.spotify.net/api/v3"
                                    "spotify-ghe" forge-github-repository))

        (magit-add-section-hook 'magit-status-sections-hook 'forge-insert-authored-pullreqs 'forge-insert-pullreqs nil)
        (magit-add-section-hook 'magit-status-sections-hook 'forge-insert-requested-reviews 'forge-insert-pullreqs nil)
        (magit-add-section-hook 'magit-status-sections-hook 'forge-insert-assigned-issues 'forge-insert-issues nil)
        (magit-add-section-hook 'magit-status-sections-hook 'forge-insert-authored-issues 'forge-insert-issues nil))
    #+END_SRC

** Helpful

   #+begin_src emacs-lisp
     (use-package helpful
       :straight t
       :bind (("C-h f" . #'helpful-callable)
              ("C-h v" . #'helpful-variable)
              ("C-h k" . #'helpful-key)
              :map helpful-mode-map
              ("Q"     . #'helpful-kill-buffers)
              ("g"     . #'helpful-update))
       :init
       (with-eval-after-load 'evil
         (add-to-list 'evil-motion-state-modes 'helpful-mode)))
   #+end_src

** =highlight-indent-guides=

   #+begin_src emacs-lisp
     (use-package highlight-indent-guides
       :straight t
       :custom
       (highlight-indent-guides-method 'character))
   #+end_src

** ivy

   #+begin_src emacs-lisp
     (use-package ivy
       :disabled t
       :straight t
       :bind (("C-s"   . swiper))
              ;; FIXME: this doesn't work
              ;; :map eshell-mode-map
              ;; ("M-r" . counsel-esh-history))
       :diminish ivy-mode
       :custom
       (ivy-use-selectable-prompt t)
       (ivy-use-virtual-buffers t)
       (ivy-count-format "(%d/%d) ")
       (ivy-extra-directories '())
       :config
       (ivy-mode 1))

     (use-package ivy-hydra
       :after ivy
       :straight t
       :custom
       (ivy-read-action-function 'ivy-hydra-read-action))

     (use-package ivy-prescient
       :after ivy
       :straight t
       :config
       (ivy-prescient-mode t)
       (prescient-persist-mode))

     (use-package counsel
       :after ivy
       :straight t
       :diminish counsel-mode
       :bind (:map counsel-mode-map
              ("C-x m" . counsel-M-x))
       :config
       (counsel-mode t))

     (use-package counsel-projectile
       :straight t
       :after (projectile counsel ivy)
       ;; :ensure-system-package
       ;; (rg . ripgrep)
       :init
       (setq counsel-projectile-sort-files t)
       (setq counsel-projectile-sort-projects t)
       (setq counsel-projectile-sort-buffers t)
       :config
       (counsel-projectile-mode t))

     ;; TODO: Consider only enabling this if emacs has been compiled w/ no-titlebar
     ;; support; posframes don't work well w/ macOS fullscreen, meaning that the only
     ;; other viable use scenario is when no-titlebar is used in conjunction w/
     ;; 3rd-party tiling fullscreen via e.g. Rectangles.app
     (use-package ivy-posframe
       ;; Weird reliablity issues where the posframe persists after switching away
       ;; from Emacs's macOS desktop to another and then back.
       :disabled t
       :straight t
       :after ivy
       :custom
       (ivy-height 30)
       :config
       (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display)))
       (ivy-posframe-mode t))

     (defun jjin/ivy-rich-package-stars (candidate)
       (unless (not (require 'paradox nil t))
         ;; FIXME: This needs to incorporate w/ paradox--refresh-remote-data
         (paradox--package-star-count (intern candidate))))

     (use-package ivy-rich
       :after ivy
       :straight t
       :config
       (plist-put ivy-rich-display-transformers-list
                  'describe-package
                  '(:columns
                   ((ivy-rich-candidate (:width 30))
                    ;; (jjin/ivy-rich-package-stars (:width 4 :face warning))
                    (ivy-rich-package-install-summary (:face font-lock-doc-face)))))

       (with-eval-after-load 'helpful
         (mapc
          (lambda (fns)
            (let* ((transformer-source (nth 1 fns))
                   (transformer-dest (nth 0 fns))
                   (transformer (plist-get ivy-rich-display-transformers-list transformer-source)))
              (plist-put ivy-rich-display-transformers-list transformer-dest transformer)))
          '((helpful-variable counsel-describe-variable) (helpful-callable counsel-describe-function))))
       (ivy-rich-mode t))
   #+end_src

** Selectrum

   Playing around with Selectrum for some commands. In particular it has better
   handling for multiple selection than Ivy.

   #+begin_src emacs-lisp
     (use-package selectrum
       :straight t
       :config
       (selectrum-mode))

     (use-package orderless
       :straight t
       :custom (completion-styles '(orderless)))

     (use-package marginalia
       :straight t
       :init
       (marginalia-mode)
       :config
       (add-to-list 'marginalia-prompt-categories '("\\<[Pp]roject\\>" . jjin/project)))

     (use-package prescient
       :straight t
       :config
       (prescient-persist-mode))

     (use-package selectrum-prescient
       :after (selectrum prescient)
       :straight t
       :config
       (selectrum-prescient-mode))

     (use-package consult
       :straight t
       :bind
       (([remap isearch-forward] . consult-line)
        ([remap switch-to-buffer] . consult-buffer))
       :config
       (with-eval-after-load 'projectile
         (bind-key [remap projectile-ripgrep] 'consult-ripgrep)))

     (use-package embark
       :straight t
       :bind
       (("C-;" . embark-act))
       :config
       (embark-define-keymap jjin/project-actions
         "Keymap for actions on projects."
         ("v" jjin/projectile-vterm-at)
         ("g" jjin/magit-status-at))
       (add-to-list 'embark-keymap-alist '(jjin/project . jjin/project-actions)))

     (use-package consult-projectile
       :after (consult projectile)
       :straight (consult-projectile
                  :type git
                  :host gitlab
                  :repo "OlMon/consult-projectile"
                  :branch "master")
       :bind (:map projectile-command-map
              ("<SPC>" . consult-projectile))
       :config
       (with-eval-after-load 'projectile
         (setq consult-project-root-function #'projectile-project-root)))
   #+end_src

** =linum=

   #+BEGIN_SRC emacs-lisp
     (use-package linum
       :straight t
       :config
       (setq linum-format 'dynamic)
       (global-linum-mode 1)

       (defconst linum-mode-allowlist
         '(prog-mode protobuf-mode yaml-mode))

       (require 'mode-local)

       (defadvice linum-mode (around linum-mode-selective activate)
         "Avoids enabling of linum-mode in the buffer having major mode set to one
     of listed in `linum-mode-excludes'."
         (if (or (member major-mode linum-mode-allowlist)
                 ;; FIXME: This should really go all the way up the major-mode
                 ;; "inheritance" chain
                 (member (get-mode-local-parent major-mode) linum-mode-allowlist))
           ad-do-it)))
   #+END_SRC

** [[https://github.com/muffinmad/emacs-mini-frame][mini-frame]]

   #+begin_src emacs-lisp
     (use-package mini-frame
       :disabled t
       :straight t
       :custom
       (mini-frame-show-parameters '((top . 0.2) (width . 0.5) (left . 0.5)))
       :config
       (mini-frame-mode -1))
   #+end_src

** =mu4e=

   =mu4e= has a notion of [[https://www.djcbsoftware.nl/code/mu/mu4e/Marking.html#Marking]["marks"]] that it uses to represent actions on messages
   -- refiling to specific directories, trashing, etc. These marks can
   furthermore be performed at the thread level to, for instance, archive an
   entire thread in one go.

   Oftentimes, I find myself -- for a variety of reasons -- wanting to archive
   only the very first email in a given thread, and trashing the rest. With
   vanilla =mu4e=, my best bet to do so is to mark an entire thread first with
   "delete," then to manually mark the thread head for archiving. Obviously,
   I'd like to perform this workflow with a single "meta-mark."

   The following predicate function will be useful.

   #+begin_src emacs-lisp
     (defun jjin/mu4e-msg-thread-head-p (&optional msg)
       "Given an mu4e message s-expression `msg', return t if the
     message is the absolute head of a thread, and nil otherwise. If
     `msg' is not provided, use the current message at point."
       (let* ((_msg (or msg (mu4e-message-at-point)))
              (thread (plist-get _msg :thread))
              (level (plist-get thread :level)))
         (zerop level)))
   #+end_src

   Now, we define a new mark to eventually add to the =mu4e-mark= list.

   #+begin_src emacs-lisp
     ;; FIXME: This mark doesn't co-operate well when trying to apply to subthread.
     (defvar jjin/mu4e-mark-refile-first-delete-rest
           '(refile-first
             :char ("R" . " ")
             :prompt "Refile head, delete rest"
             :dyn-target
             (lambda (target msg)
               (let ((f-folder-get
                      (if (jjin/mu4e-msg-thread-head-p msg)
                          'mu4e-get-refile-folder
                        'mu4e-get-trash-folder)))
                 (funcall f-folder-get msg)))
             :action
             (lambda (docid msg target)
               (let* ((key-mark
                       (if (jjin/mu4e-msg-thread-head-p msg)
                           'refile
                         'trash))
                      (mark (alist-get key-mark mu4e-marks))
                      (f-action (plist-get mark :action)))
                 (funcall f-action docid msg target))))
           "An mu4e mark action that, when applied to messages in a
     thread, will archive the head of the thread and trash the rest.")
   #+end_src

   Now for the rest of the config:

   #+BEGIN_SRC emacs-lisp
     (use-package mu4e
       :ensure-system-package (mu)
       ;;  (mbsync . isync)
       ;;  (w3m . w3m))
       :custom
       (mail-user-agent 'mu4e-user-agent)
       (mu4e-view-show-addresses t)
       (mu4e-compose-context-policy 'ask)
       (mu4e-update-interval nil)
       (mu4e-headers-skip-duplicates t)
       (mu4e-view-show-images t)
       (mu4e-compose-signature-auto-include nil)
       (mu4e-html2text-command 'mu4e-shr2text)
       ;; don't keep message buffers around
       (message-kill-buffer-on-exit t)
       (mu4e-context-policy 'pick-first)
       (mu4e-headers-include-related nil)
       (mu4e-view-use-gnus nil)
       (mu4e-change-filenames-when-moving t)
       (mu4e-split-view 'single-window)
       (mu4e-compose-format-flowed t)
       (message-send-mail-function 'smtpmail-send-it)
       (mu4e-bookmarks '((:query "(maildir:\"/personal/INBOX\" OR maildir:\"/work/INBOX\") flag:unread"
                          :name "Unread INBOXes"
                          :key ?U)
                         (:query "from:\"notification@fbworkmail.com\""
                          :name "Workface"
                          :key ?w)))
       :commands (mu4e mu4e-update-mail-and-index)
       :init
       (defhydra jjin-hydra-mu4e (:exit t)
         "Auxiliary commands for mu4e"
         ("m" mu4e-update-mail-and-index "update"))

       :config
       (with-eval-after-load 'ivy
         (setq mu4e-completing-read-function 'ivy-completing-read))

       (when (eq system-type 'darwin)
         (setq mu4e-mu-binary "/usr/local/bin/mu"))

       ;; don't save message to Sent Messages for GMail accounts; Gmail/IMAP takes
       ;; care of this
       (setq mu4e-sent-messages-behavior
             (lambda ()
               (if (string= (message-sendmail-envelope-from) "jjin@spotify.com")
                   'delete
                 'sent)))

       (setq mu4e-maildir-shortcuts
             '(("/personal/INBOX"   . ?i)
               ("/personal/Sent"    . ?s)
               ("/personal/Drafts"  . ?d)
               ("/personal/Archive" . ?a)
               ("/work/INBOX" . ?I)
               ("/work/sent" . ?S)
               ("/work/drafts" . ?D)
               ("/work/archive" . ?A)))

       (setq mu4e-get-mail-command (if (not (executable-find "mbsync")) "true" "mbsync -Va"))

       (setq shr-use-colors nil)
       (setq shr-use-fonts nil)

       (add-hook 'mu4e-view-mode-hook 'visual-line-mode)

       (use-package gnus-dired
         :config
         ;; make the `gnus-dired-mail-buffers' function also work on message-mode derived
         ;; modes, such as mu4e-compose-mode
         (defun gnus-dired-mail-buffers ()
           (let (buffers)
             (save-current-buffer
               (dolist (buffer (buffer-list t))
                 (set-buffer buffer)
                 (when (and (derived-mode-p 'message-mode)
                            (null message-sent-message-via))
                   (push (buffer-name buffer) buffers))))
             (nreverse buffers)))

         (setq gnus-dired-mail-mode 'mu4e-user-agent)
         (add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode))

       (set-face-attribute 'mu4e-header-highlight-face nil :underline nil)

       (add-to-list 'mu4e-view-actions
                    '("View in browser" . mu4e-action-view-in-browser)
                    t)
       (add-to-list 'mu4e-view-actions
                    '("Capture message" . mu4e-action-capture-message)
                    t)

       (defun mu4e-message-maildir-matches (msg rx)
         (when rx
           (if (listp rx)
               ;; if rx is a list, try each one for a match
               (or (mu4e-message-maildir-matches msg (car rx))
                   (mu4e-message-maildir-matches msg (cdr rx)))
             ;; not a list, check rx
             (string-match rx (mu4e-message-field msg :maildir)))))

       (setq mu4e-contexts
             `(,(make-mu4e-context
                 :name "personal"
                 :match-func
                 (lambda (msg)
                   (when msg
                     (or
                      (mu4e-message-maildir-matches msg "^/personal")
                      (mu4e-message-contact-field-matches msg :to "jjin082693@gmail.com")
                      (mu4e-message-contact-field-matches msg :to "me@jonathanj.in"))))
                 :vars `((user-mail-address . "me@jonathanj.in")
                         (mu4e-compose-signature . ,(concat "Jonathan Jin"))

                         (smtpmail-smtp-user . "me@jonathanj.in")
                         (smtpmail-smtp-server . "smtp.fastmail.com")
                         (smtpmail-smtp-service . 465)
                         (smtpmail-stream-type . ssl)

                         (user-full-name . "Jonathan Jin")
                         (mu4e-sent-folder . "/personal/Sent")
                         (mu4e-trash-folder . "/personal/Trash")
                         (mu4e-drafts-folder . "/personal/Drafts")
                         (mu4e-refile-folder . "/personal/Archive")))

               ,(make-mu4e-context
                 :name "work"
                 :match-func
                 (lambda (msg)
                   (when msg
                     (or
                      (mu4e-message-maildir-matches msg "^/work")
                      (mu4e-message-contact-field-matches msg :to "jjin@spotify.com"))))
                 :vars `((user-mail-address . "jjin@spotify.com")
                         (mu4e-compose-signature . ,(concat "Jonathan Jin"))

                         (smtpmail-smtp-user . "jjin@spotify.com")
                         (smtpmail-smtp-server . "smtp.gmail.com")
                         (smtpmail-smtp-service . 587)
                         (smtpmail-stream-type . nil)

                         (user-full-name . "Jonathan Jin")
                         (mu4e-sent-folder . "/work/sent")
                         (mu4e-trash-folder . "/work/trash")
                         (mu4e-drafts-folder . "/work/drafts")
                         (mu4e-refile-folder . "/work/Archive")))))

       ;; Sets `mu4e-user-mail-address-list' to the concatenation of all
       ;; `user-mail-address' values for all contexts. If you have other mail
       ;; addresses as well, you'll need to add those manually.
       (setq mu4e-user-mail-address-list
             (delq nil
                   (mapcar (lambda (context)
                             (when (mu4e-context-vars context)
                               (cdr (assq 'user-mail-address (mu4e-context-vars context)))))
                           mu4e-contexts)))

       (add-to-list 'mu4e-marks jjin/mu4e-mark-refile-first-delete-rest)

       ;; (setq projectile-globally-ignored-modes (remove-if 'symbolp projectile-globally-ignored-modes ))
       (with-eval-after-load 'projectile
         (mapc
          (lambda (mode)
            (add-to-list 'projectile-globally-ignored-modes (symbol-name mode)))
          '(mu4e-headers-mode
            mu4e~update-mail-mode
            mu4e~main-toggle-mail-sending-mode
            mu4e-main-mode
            mu4e-view-mode
            mu4e~view-define-mode
            mu4e-compose-mode
            mu4e-org-mode))))
   #+END_SRC

** =org-mode=


   #+BEGIN_SRC emacs-lisp
     ;; NB(@jinnovation): Copied wholesale from org-compat.el. This *should* be
     ;; accessible, but for some reason is not, resulting in (void-function
     ;; org-file-name-concat) when loading up org-mode buffers.
     ;;
     ;; TODO: Investigate and remove sometime.
     (if (fboundp 'file-name-concat)
         (defalias 'org-file-name-concat #'file-name-concat)
       (defun org-file-name-concat (directory &rest components)
         "Append COMPONENTS to DIRECTORY and return the resulting string.

     Elements in COMPONENTS must be a string or nil.
     DIRECTORY or the non-final elements in COMPONENTS may or may not end
     with a slash -- if they don't end with a slash, a slash will be
     inserted before contatenating."
         (save-match-data
           (mapconcat
            #'identity
            (delq nil
                  (mapcar
                   (lambda (str)
                     (when (and str (not (seq-empty-p str))
                                (string-match "\\(.+\\)/?" str))
                       (match-string 1 str)))
                   (cons directory components)))
            "/"))))


     (defun jjin/save-last-clock-buffer()
       "Save the buffer containing the last clock-in."
       (interactive)
       (let ((buffer (marker-buffer (car org-clock-history))))
         (when (not (s-equals-p "*scratch*" (buffer-name buffer)))
           (with-current-buffer buffer (save-buffer)))))

     (use-package org
       :bind (:map org-mode-map
              ("RET" . org-return-indent)
              ("M-p" . outline-previous-visible-heading)
              ("M-n" . outline-next-visible-heading)
              ("s-t" . org-todo)
              ("M-[" . org-metaleft)
              ("M-]" . org-metaright)
              :map org-src-mode-map
              ([remap evil-write] . org-edit-src-save))
       :straight t
       :mode ("\\.org$" . org-mode)

       :hook
       ((org-clock-out org-clock-in) . jjin/save-last-clock-buffer)

       :custom
       (org-adapt-indentation t)
       (org-catch-invisible-edits 'show-and-error)
       (org-return-follows-link t)
       (org-export-dispatch-use-expert-ui t)
       (org-clock-out-remove-zero-time-clocks t)
       (org-latex-create-formula-image-program 'imagemagick)
       (org-latex-listings nil)
       ;; (org-latex-listings 'minted)
       (org-tags-column -80)
       (org-enforce-todo-dependencies t)
       (org-enforce-todo-checkbox-dependencies  t)
       (org-pretty-entities t)
       (org-src-fontify-natively t)
       (org-list-allow-alphabetical t)
       (org-special-ctrl-a/e t)
       (org-deadline-warning-days 7)

       :init
       (setq org-agenda-custom-commands
             '(("s" "Schoolwork"
                ((agenda "" ((org-agenda-ndays 14)
                             (org-agenda-start-on-weekday nil)
                             (org-agenda-prefix-format " %-12:c%?-12t% s")))
                 (tags-todo "CATEGORY=\"Schoolwork\""
                            ((org-agenda-prefix-format "%b")))))

               ("r" "Reading"
                ((tags-todo "CATEGORY=\"Reading\""
                            ((org-agenda-prefix-format "%:T ")))))
               ("m" "Movies"
                ((tags-todo "CATEGORY=\"Movies\""
                            ((org-agenda-prefix-format "%:T ")))))))
         (setq
         ;;  org-latex-pdf-process (list "latexmk -shell-escape -pdf %f")

         org-entities-user
         '(("supsetneqq" "\\supsetneqq" t "" "[superset of above not equal to]"
            "[superset of above not equal to]" "⫌")
           ("subseteq" "\\subseteq" t "" "[subset of above equal to]" "subset of above equal to" "⊆")
            ("subsetneqq" "\\subsetneqq" t "" "[suberset of above not equal to]"
              "[suberset of above not equal to]" "⫋")))

       :config
       (setq org-agenda-files '("~/agenda/"))
       ;; (plist-put org-format-latex-options :scale 1.5)

       ;; NB(jjin): Uncomment if you want syntax highlighting for code snippets
       ;; (setq org-latex-packages-alist
       ;;   '(("" "minted") ("usenames,dvipsnames,svgnames" "xcolor")))

       (defun my-org-autodone (n-done n-not-done)
         "Switch entry to DONE when all subentries are done, to TODO otherwise."
         (let (org-log-done org-log-states)   ; turn off logging
           (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

       (add-hook 'org-after-todo-statistics-hook 'my-org-autodone)

       (org-babel-do-load-languages
         'org-babel-load-languages
         '((emacs-lisp . t)
            (latex     . t)
            (python    . t)
            ;; FIXME: Make this contingent on ob-ipython
            ;; (ipython   . t)
            (R         . t)
            (octave    . t)
            (matlab    . t)
            (shell     . t)))

       (setq org-confirm-babel-evaluate nil)
       (setq org-export-use-babel t)

       (setq org-latex-minted-options
         '(("linenos" "true")
            ("fontsize" "\\scriptsize")
            ("frame" "lines")))

       (setq org-export-latex-hyperref-format "\\ref{%s}")

       (setq
         org-src-window-setup 'current-window
         org-agenda-window-setup 'current-window)

       (setq org-blank-before-new-entry
         '((heading . true)
            (plain-list-item . auto)))

       ;; FIXME: parameter-ize dir `agenda'
       (setq org-default-notes-file "~/agenda/notes.org")

       (setq org-capture-templates
             `(("r" "Reading" entry (file "~/proj/lists/read.org")
                "* TODO %?\n  Entered on %U\n  %i")
               ("t" "Task" entry (file "")
                "* TODO %?\n %i")))

       (setq org-refile-targets '((nil . (:maxlevel . 10))))

       (setq org-export-with-smart-quotes t)
       (with-eval-after-load 'ace-link
         ;; (bind-keys :map org-agenda-mode-map
         ;;            ("M-o" . ace-link-org))
         (bind-keys :map org-mode-map
                    ("M-o" . ace-link-org))))

     (use-package ox-latex
       :disabled t
       :after org)

     (use-package ox-bibtex
       :disabled t
       :after org)

     (use-package ox-md
       :after org)

     (use-package ob-python
       :after org
       :init
       (setq org-babel-python-command "python3"))

     (use-package toc-org
       :disabled t
       :after org
       :config
       (add-hook 'org-mode-hook 'toc-org-enable))

     (use-package evil-org
       :straight t
       :after (evil org)
       :diminish evil-org-mode
       :config
       (add-hook 'org-mode-hook 'evil-org-mode)
       (evil-org-set-key-theme)
       (setq evil-org-special-o/O '(table-row)))

     (use-package org-sticky-header
       :disabled t
       :straight t
       :hook (org-mode . org-sticky-header-mode)
       :init
       (setq org-sticky-header-always-show-header nil)
       (setq org-sticky-header-outline-path-separator " > ")
       (setq org-sticky-header-full-path 'full))

     (use-package org-chef
       :disabled t
       :straight t)

     (use-package org-download
       :after org
       :disabled t
       :straight t)

     (use-package org-contrib
       :straight t
       :after org)

     (use-package ox-extra
       :after (org-contrib org)
       :config
       (ox-extras-activate '(latex-header-blocks ignore-headlines)))
   #+END_SRC

** =org-msg=

   For sending HTML emails from mu4e etc

   #+begin_src emacs-lisp
     (use-package org-msg
       :straight t
       ;; load after mu4e to pick up mail-user-agent setting
       :after (mu4e org)
       :custom
       (org-msg-default-alternatives '(text html))
       (org-msg-options "html-postamble:nil num:nil toc:nil author:nil email:nil")
       (org-msg-signature "

     ,#+begin_signature
     -- \\\\
     Jonathan Jin
     ,#+end_signature")
       :config
       (org-msg-mode))
   #+end_src

** Org-roam

   #+begin_src emacs-lisp
     (defun jjin/org-roam-node-from-cite (keys-entries)
       "Create an Org-Roam node from a citation.

     Shamelessly stolen from Jethro Kuan:
     https://jethrokuan.github.io/org-roam-guide."
       (interactive (list (citar-select-ref :multiple nil :rebuild-cache t)))
       (let ((title (citar--format-entry-no-widths (cdr keys-entries) "${author editor} :: ${title}")))
         (org-roam-capture- :templates
                            '(("r" "reference" plain "%?"
                               :if-new (file+head "reference/${citekey}.org"
                                                  ":PROPERTIES:
     :ROAM_REFS: [cite:@${citekey}]
     :END:
     ,#+TITLE: ${title}\n")
                               :immediate-finish t
                               :unnarrowed t))
                            :info (list :citekey (car keys-entries))
                            :node (org-roam-node-create :title title)
                            :props '(:finalize find-file))))

     (with-eval-after-load 'org
       (define-derived-mode jjin/org-roam-mode org-mode "Org-Roam"
         "Major mode for working with Org-Roam node buffers.

            This is distinct from `org-roam-mode', which is used for
            Org-Roam's sidebar buffer displaying reflinks and the like.")

       (defun jjin/enable-org-roam-mode-maybe ()
         "Enable `jjin/org-roam-mode' for buffer conditionally."
         (require 'projectile)
         (require 'f)
         (when (and (boundp 'org-roam-directory)
                    (not (eq 'jjin/org-roam-mode major-mode))
                    (f-equal? (projectile-project-root) org-roam-directory))
           (jjin/org-roam-mode)))

       (defun jjin/org-roam-ref-add-citation (cite-key)
         "Add CITE-KEY to the node at point as a reference."
         (interactive (list (car (citar-select-ref :multiple nil :rebuild-cache t))))
         (org-roam-ref-add (format "[cite:@%s]" cite-key)))

       (use-package org-roam
         :straight t
         :after org
         :hook (org-mode . jjin/enable-org-roam-mode-maybe)
         ;; :hook
         ;; (after-init . org-roam-mode)
         :init
         (setq org-roam-v2-ack t)
         (setq org-roam-directory "~/roam")
         (setq jjin/default-bibliography `(,(expand-file-name "biblio.bib" org-roam-directory)))
         :custom
         (org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
         (org-roam-mode-section-functions
          (list #'org-roam-backlinks-section
                #'org-roam-reflinks-section
                #'org-roam-unlinked-references-section
                ))
         (org-roam-capture-templates
          '(
            ("d" "default" plain "%?" :if-new
             (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
             :unnarrowed t)
            ("R"
             "Reading"
             entry
             "* ${title}%?
              %l"
             :if-new (file "~/roam/20210108105150-reading_list.org")
             :empty-lines-before 1
             :unnarrowed t
             )
            ))
         :config
         (pretty-hydra-define jjin/org-roam-actions-nodes
           (:foreign-keys warn :title "Org-Roam: Node Actions" :quit-key "C-g")
           ("Find"
            (("f" org-roam-node-find "and open")
             ("i" org-roam-node-insert "and insert"))
            "Create"
            (("c" jjin/org-roam-node-from-cite "from citation"))))

         ;; TODO: Nest hydras, e.g. for tag actions, to rm risk of key collisions
         (major-mode-hydra-define jjin/org-roam-mode
           (:title "Org-Roam: Commands")
           ("Node"
            (("f" org-roam-node-find "Find")
             ("i" org-roam-node-insert "Insert"))
            "Database"
            (("d" org-roam-db-sync "Sync"))
            "Edit"
            (("t" org-id-get-create "Tag w/ ID")
             ("a" org-roam-alias-add "Add alias")
             ("r" org-roam-ref-add "Add reference")
             ("c" jjin/org-roam-ref-add-citation "Add citation"))
            "View"
            (("B" org-roam-ui-open "Graph in browser")
             ("b" org-roam-buffer-toggle "Sidebar"))
            "Actions"
            (("n" jjin/org-roam-actions-nodes/body "Nodes"))
            "Tags"
            (("T" org-roam-tag-add "Add")))))

         (org-roam-db-autosync-enable))

       ;; All stuff from org-roam v1 that needs to get audited and
       ;; reimpemented for v2 if necessary
       ;; :custom
       ;; (org-roam-tag-sources '(prop all-directories))
       ;; :config
       ;; (setq org-roam-graph-viewer (if (eq system-type 'darwin) "open" nil))
       ;; (add-to-list 'org-roam-capture-templates
       ;;              '("r"
       ;;               "reading"
       ;;               plain
       ;;               (function org-roam--capture-get-point)
       ;;               "%?"
       ;;               :file-name "reading/%<%Y%m%d%H%M%S>-${slug}"
       ;;               :head "#+title: ${title}\n\n* 作者\n  "
       ;;               :unnarrowed t))
       ;; (with-eval-after-load 'pretty-hydra
       ;;   (pretty-hydra-define jjin-hydra-roam
       ;;     (:title (with-octicon "pencil" "Notes (Roam)" 1 -0.05))
       ;;     ("Find"
       ;;      (("f" org-roam-find-file "file"))))
       ;;   (bind-key "s-r" 'jjin-hydra-roam/body)))

       ;; TODO: Add to jjin-hydra-roam a key to open the graph in browser
       (use-package org-roam-server
         :disabled t
         :after org-roam
         :straight t
         :config
         (setq org-roam-server-host "127.0.0.1"
               org-roam-server-port 8080
               org-roam-server-authenticate nil
               org-roam-server-export-inline-images t
               org-roam-server-serve-files nil
               org-roam-server-served-file-extensions '("pdf" "mp4" "ogv")
               org-roam-server-network-poll t
               org-roam-server-network-arrows nil
               org-roam-server-network-label-truncate t
               org-roam-server-network-label-truncate-length 60
               org-roam-server-network-label-wrap-length 20))

       (use-package org-roam-ui
         :straight t
         :after org-roam)

       ;; (use-package org-ref
       ;;   :straight t)

       (use-package citar
         :straight t
         :after org-roam
         :custom
         (citar-bibliography jjin/default-bibliography)
         (org-cite-insert-processor 'citar)
         (org-cite-follow-processor 'citar)
         (org-cite-activate-processor 'citar)
         (org-cite-global-bibliography jjin/default-bibliography)
         :config
         (major-mode-hydra-define+ jjin/org-roam-mode nil
           ("Citation"
            (("c" citar-insert-citation "Insert"))))
         (let ((entry (cons '(jjin/org-roam-mode) (cdr (seq-find
                               (lambda (modefns)
                                 (let ((modes (car modefns)))
                                   (-contains? modes 'org-mode)))
                               citar-major-mode-functions))
                         )))
           (add-to-list 'citar-major-mode-functions entry
           )))

       (use-package bibtex-completion
         :straight t
         :after org-roam
         :custom
         (bibtex-completion-bibliography jjin/default-bibliography))

       (use-package org-roam-bibtex
         :straight t
         :after org-roam
         :custom
         (orb-citekey-format 'org-cite))
   #+end_src

** Modeline

   #+begin_src emacs-lisp
     (use-package all-the-icons
       :straight t

       :config
       (defun with-faicon (icon str &optional height v-adjust)
         (s-concat (all-the-icons-faicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

       (defun with-fileicon (icon str &optional height v-adjust)
         (s-concat (all-the-icons-fileicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

       (defun with-octicon (icon str &optional height v-adjust)
         (s-concat (all-the-icons-octicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

       (defun with-material (icon str &optional height v-adjust)
         (s-concat (all-the-icons-material icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str)))

     ;; FIXME: Make this conditional on fonts not being present
     ;; Maybe check ~/Library/Fonts/octicons.ttf etc for presence?

     ;; (all-the-icons-install-fonts)

     (use-package doom-modeline
       :straight t
       :config
       (setq doom-modeline-vcs-max-length 24)

       (setq doom-modeline-buffer-file-name-style 'truncate-except-project)

       (doom-modeline-def-segment jjin/datetime
         (when (doom-modeline--active)
           (concat
            (doom-modeline-spc)
            (doom-modeline-icon 'faicon "clock-o" "" "" :height 1.0 :v-adjust 0.04)
            (doom-modeline-vspc)
            (propertize (format-time-string "%h %d %T") 'face 'mode-line)
            (doom-modeline-spc))))

       (doom-modeline-def-modeline 'jjin
         '(bar workspace-name window-number modals matches buffer-info remote-host selection-info )
         '(misc-info persp-name jjin/datetime battery irc mu4e debug lsp minor-modes input-method indent-info process vcs checker))

       (add-hook 'doom-modeline-mode-hook (lambda () (doom-modeline-set-modeline 'jjin t)))

       (setq doom-modeline-buffer-encoding nil)
       (setq doom-modeline-height (min doom-modeline-height (default-font-height)))
       (doom-modeline-mode 1))

     (display-battery-mode 1)
   #+end_src

** =pdf-tools=

   #+BEGIN_SRC emacs-lisp
     (use-package pdf-tools
       :straight t
       :mode ("\\.pdf$" . pdf-view-mode)
       :config
       (pdf-tools-install)

       (let ((foreground-orig (car pdf-view-midnight-colors)))
         (setq pdf-view-midnight-colors
               (cons "white" "black")))

       (with-eval-after-load 'evil
           (progn
             (add-to-list 'evil-emacs-state-modes 'pdf-outline-buffer-mode)
             (add-to-list 'evil-emacs-state-modes 'pdf-view-mode))))
   #+END_SRC

** =projectile=

   #+begin_src emacs-lisp
     ;; TODO: For sake of Constant Reader, give some context as to why this might be
     ;; necessary (at least for me)
     (defun jjin/projectile-absolute-compilation-dir-maybe ()
       "Returns the default compilation dir of the current Projectile project type if
       it is an absolute path; otherwise, return nil."
       (let* ((type (projectile-project-type))
              (comp-dir (projectile-default-compilation-dir type)))
         (if (and comp-dir (file-name-absolute-p comp-dir)) comp-dir nil)))


     (defun jjin/projectile-find-test-file-cwd-first (&optional invalidate-cache)
       "TODO"
       )
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :straight t
       :diminish projectile-mode
       :ensure-system-package (ripgrep)
       :custom
       (projectile-ignored-projects '("/Users/jjin/"))
       (projectile-enable-caching t)
       (projectile-sort-order 'recently-active)
       :init
       (setq projectile-globally-ignored-files
             '("TAGS" "GPATH" "GRTAGS" "GSYMS" "GTAGS"))
       (setq projectile-globally-ignored-file-suffixes '("~"))

       ;; We'd like projects contained within other projects, e.g. packages pulled
       ;; into the .emacs.d/.straight dir via straight.el, to be recognized as
       ;; Projectile packages.
       (setq projectile-project-root-functions
             '(projectile-root-local
               projectile-root-bottom-up
               projectile-root-top-down
               projectile-root-top-down-recurring))

       :config
       (with-eval-after-load 'ivy
         (setq projectile-completion-system 'ivy))

       (defun jjin/projectile-vterm-at (dir)
         "Invoke `vterm' in the given project dir.

     Switch to the project specific term buffer if it already exists.

     This is a 'fork' of `projectile-run-vterm' to enable directory injection, for
     use as an Embark action."

         (let* ((project (projectile-acquire-root dir))
                (buffer (projectile-generate-process-name "vterm" nil project)))
           (unless (buffer-live-p (get-buffer buffer))
             (unless (require 'vterm nil 'noerror)
               (error "package 'vterm' is not available"))
             (projectile-with-default-dir project
               (vterm buffer)))
           (switch-to-buffer buffer)))

       (define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
       (advice-add 'projectile-compilation-dir
                   :before-until
                   'jjin/projectile-absolute-compilation-dir-maybe)

       ;; MacOS file system is case insensitive. This means that, when combined with
       ;; top-down root discovery, .git directory's `description' file conflicts with
       ;; the `DESCRIPTION' element -- intended for R projects -- in the default
       ;; value of `projectile-project-root-file'.
       ;;
       ;; Since I really don't use R and don't plan to anytime soon, removing it from
       ;; here. Can revisit if/when ever necessary.
       (setq projectile-project-root-files
             (remove "DESCRIPTION" projectile-project-root-files))
       (bind-key "<f12>"
                 (lambda ()
                   "Save all project buffers and compile"
                   (interactive)
                   (projectile-save-project-buffers)
                   (let (compilation-read-command)
                     (projectile-compile-project nil)))
                 projectile-mode-map)

       (bind-key "c"
                 (lambda (arg)
                   "Run `helm-make-projectile' if the package is
     installed and the project contains a Makefile. Otherwise,
     fallback to default, i.e. `projectile-compile-project'."
                   (interactive "P")
                   (if (and (package-installed-p 'helm-make)
                            (file-exists-p (concat (projectile-project-root) "Makefile")))
                       (helm-make-projectile (prefix-numeric-value arg))
                     (projectile-compile-project arg)))
                 projectile-command-map)

       (with-eval-after-load 'helm-projectile
           (setq projectile-completion-system 'helm
                 projectile-switch-project-action 'helm-projectile))

       (projectile-global-mode)

       ;; "disables "mode-line setting by project; extreme hang-up over SSH/Tramp
       (setq projectile-mode-line "Projectile")
       (add-to-list 'projectile-globally-ignored-modes "term-mode")

       (use-package ggtags
         :disabled t
         :config
         (with-eval-after-load 'evil
             (add-to-list 'evil-emacs-state-modes 'ggtags-view-search-history-mode))

         (add-hook 'c-mode-hook 'ggtags-mode)
         (add-hook 'c++-mode-hook 'ggtags-mode)
         (add-hook 'java-mode-hook 'ggtags-mode)))
   #+END_SRC

** =rich-minority-mode=

   #+BEGIN_SRC emacs-lisp
     (use-package rich-minority
       :straight t
       :config
       (defconst my-rm-excluded-modes
         '(
            " pair"
            " Fill"
            " end"
            " Ace - Window"))
       (dolist (mode my-rm-excluded-modes)
         (add-to-list 'rm-excluded-modes mode)))
   #+END_SRC

** =smart-mode-line=

   #+BEGIN_SRC emacs-lisp
     (use-package smart-mode-line
       :disabled t
       :straight t
       :custom
       (sml/theme 'respectful)
       :config
       (sml/setup)
       (smart-mode-line-enable))
   #+END_SRC

** =tramp=

   #+BEGIN_SRC emacs-lisp
     (use-package tramp
       :custom
       (tramp-default-method "ssh")
       (password-cache-expiry nil)
       :config
       (add-to-list 'tramp-remote-path "~/bin"))
   #+END_SRC

** =undo-tree=

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :straight t
       :diminish undo-tree-mode
       :bind ("C-<backspace>" . undo-tree-undo)
       :config
       (global-undo-tree-mode)
       (with-eval-after-load 'evil
         (evil-set-undo-system 'undo-tree)))
   #+END_SRC

** =w3m=

   #+BEGIN_SRC emacs-lisp
     (use-package w3m
       :straight t
       :bind (:map w3m-mode-map
              ("P" . w3m-view-previous-page)
              ("n" . w3m-tab-next-buffer)
              ("p" . w3m-tab-previous-buffer)
              ("w" . w3m-delete-buffer))
       :commands w3m
       :init
       (setq w3m-fill-column 80)

       :config
       (with-eval-after-load 'evil
         (add-to-list 'evil-emacs-state-modes 'w3m-session-select-mode))
       (with-eval-after-load 'ace-link
         (bind-keys :map w3m-mode-map
                    ("o" . ace-link-w3m)))

       (unbind-key "B" w3m-mode-map))

     (use-package w3m-session
       :after w3m)
   #+END_SRC

** Ripgrep

   #+begin_src emacs-lisp
     (use-package ripgrep
       :straight t)
   #+end_src

** Shackle

   #+begin_quote
   =shackle= gives you the means to put an end to popped up buffers not behaving
   they way you'd like them to. By setting up simple rules you can for instance
   make Emacs always select help buffers for you or make everything reuse your
   currently selected window.
   #+end_quote

   #+begin_src emacs-lisp
     (use-package shackle
       :straight t
       :custom
       (shackle-rules '(
                        (git-commit-mode :align bottom :size 0.3 :select t)
                        ('(help-mode helpful-mode) :select t :other t :inhibit-window-quit t :size 0.4)
                        (vterm-mode :align right :size 0.4 :select t)
                        (magit-log-mode :other t :size 0.4 :select t)
                        (kubernetes-overview-mode :same t :inhibit-window-quit t)

                        ;; TODO: Find a way to have this open in the current window
                        ;; iff there is no other window in the frame
                        (magit-status-mode :select t :other t :size 0.4)
                        (compilation-mode :align right :size 0.3 :other t :inhibit-window-quit t)))
       :config
       (shackle-mode t))
   #+end_src

** Popper

   #+begin_quote
   Popper is a minor-mode to tame the flood of ephemeral windows Emacs produces,
   while still keeping them within arm’s reach. Designate any buffer to “popup”
   status, and it will stay out of your way. Disimss or summon it easily with
   one key. Cycle through all your “popups” or just the ones relevant to your
   current buffer. Useful for many things, including toggling display of REPLs,
   documentation, compilation or shell output, etc.
   #+end_quote

   #+begin_src emacs-lisp
     (use-package popper
       :disabled t
       :straight t
       :custom
       (popper-group-function #'popper-group-by-projectile)
       :bind (("C-`"   . popper-toggle-latest)
              ("M-`"   . popper-cycle)
              ("C-M-`" . popper-toggle-type))
       :init
       (setq popper-reference-buffers
             '("\\*Messages\\*"
               "Output\\*$"
               "vterm .+\\*$"
               help-mode
               helpful-mode
               compilation-mode))
       (popper-mode +1))
   #+end_src

* Cloud computing

** Terraform

   #+begin_src emacs-lisp
     (use-package terraform-mode
       :ensure-system-package (tfenv terraform)
       :straight t)
       ;; :hook (terraform-mode . terraform-format-on-save-mode))

     (use-package company-terraform
       :after terraform-mode
       :straight t)
   #+end_src
** =helm=

   #+BEGIN_SRC emacs-lisp
     (use-package helm
       :straight t
       :demand t
       :disabled t
       :diminish helm-mode
       :bind (("C-x m"    . helm-M-x)
              ("M-x"      . helm-M-x)
              ("C-x C-f" . helm-find-files)
              ("C-x b"   . helm-buffers-list))
       :init
       (setq helm-external-programs-associations `(("pdf" . ,(if (eq system-type 'darwin) "open" "zathura"))))
       (setq helm-split-window-inside-p t)

       (setq helm-mode-fuzzy-match t)

       :config
       (helm-mode 1)
       (helm-autoresize-mode t)

       (defvar helm-source-file-not-found
         (helm-build-dummy-source
             "Create file"
           :action
           (lambda (c) (find-file c))))

       (bind-keys :map jjin-vc-map
                  ("g" . helm-grep-do-git-grep))

       ;; (bind-key "C-c C-j" 'helm-org-in-buffer-headings org-mode-map)

       (setq helm-ff-candidate-number-limit 500))

     (use-package helm-make
       :disabled t
       :straight t
       :after helm
       :commands helm-make-projectile
       :init
       (setq helm-make-cache-targets t)
       (setq helm-make-list-target-method 'qp))

     (use-package helm-projectile
       :disabled t
       :after (helm projectile)
       :bind (:map projectile-command-map
                   ("TAB" . helm-projectile-switch-project)
                   ("p"   . helm-projectile)
                   ("a"   . helm-projectile-find-other-file)
                   ("f"   . helm-projectile-find-file)
                   ("F"   . helm-projectile-find-file-in-known-projects)
                   ("s s" . helm-projectile-ag)
                   ("s g" . helm-projectile-grep))
       :straight t
       :config
       (add-to-list 'helm-projectile-sources-list helm-source-file-not-found t))
   #+END_SRC
** Kubernetes

   #+begin_src emacs-lisp
     (use-package kubernetes
       :straight (:local-repo "~/dev/kubernetes-el" :type git :host github :repo "kubernetes-el/kubernetes-el")
       :custom
       (kubernetes-commands-display-buffer-function 'display-buffer "Display like a regular buffer instead of obnoxious full-frame takeover.")
       (kubernetes-overview-custom-views-alist '((jjin-overview . (context deployments pods))))
       :config
       (fset 'k8s 'kubernetes-overview)
       (with-eval-after-load 'evil
         (evil-set-initial-state 'kubernetes-mode 'emacs)
         (evil-set-initial-state 'kubernetes-display-thing-mode 'visual)
         (evil-set-initial-state 'kubernetes-log-line-mode 'emacs)
         (evil-set-initial-state 'kubernetes-logs-mode 'emacs)
         (evil-set-initial-state 'kubernetes-overview-mode 'emacs))

       ;; (kubernetes-state--define-accessors profiles (profiles)
       ;;   (cl-assert (listp profiles)))

       ;; (setq kubernetes-overview-custom-views-alist '((profiles profiles)))

       ;; ;; TODO: Define kubernetes-state-update-profile
       ;; (defun kubernetes-kubectl-get-profile (props state cb &optional cleanup-db)
       ;;   (kubernetes-kubectl props state '("get" "profiles" "-o" "json")
       ;;                       (lambda (buf)
       ;;                         (let ((json (with-current-buffer buf
       ;;                                       (json-read-from-string (buffer-string)))))
       ;;                           (funcall cb json)))
       ;;                       nil
       ;;                       cleanup-cb))
       )
   #+end_src

* Org-drill

  I've been using Anki for a while but I'm starting to get annoyed at constantly
  having to reinstall random crap every single time...

  #+begin_src emacs-lisp
    (use-package org-drill
      :straight t
      ;; TODO:
      ;;
      ;; Custom card type that can take a sentence like the following:
      ;; 壁の向こう側にいる相手と声の[やり取り]だけで相性を[見極めて]いくのです
      ;; And create cards that ask for the meaning of the clozed term.
      )
  #+end_src
