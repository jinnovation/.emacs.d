# -*- after-save-hook: (org-babel-tangle); -*-

#+TITLE: Jonathan Jin's Emacs Configuration
#+AUTHOR: Jonathan Jin
#+PROPERTY: header-args:emacs-lisp :exports code :results none :tangle init.el

#+EXPORT_FILE_NAME: index

#+SETUPFILE: theme.setup

* Preamble

  #+BEGIN_SRC emacs-lisp
    (add-to-list 'load-path (expand-file-name "~/.emacs.d/elpa"))

    (setq package-archives '(("gnu"           . "http://elpa.gnu.org/packages/")
                              ("melpa-stable" . "http://stable.melpa.org/packages/")
                              ("melpa"        . "http://melpa.org/packages/")
                              ("org"          . "http://orgmode.org/elpa/")))

    (package-initialize)
  #+END_SRC

** Front Matter

*** Straight

    #+BEGIN_SRC emacs-lisp
      (let ((bootstrap-file
             (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
            (bootstrap-version 4))
        (unless (file-exists-p bootstrap-file)
          (with-current-buffer
              (url-retrieve-synchronously
               "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
               'silent 'inhibit-cookies)
            (goto-char (point-max))
            (eval-print-last-sexp)))
        (load bootstrap-file nil 'nomessage))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (straight-use-package 'use-package)
      (use-package use-package-ensure-system-package
        :straight t)
    #+END_SRC
    
*** =use-package=

    The =:if= clause lets us suppress configuration/loading of a given package
    if a provided condition doesn't hold. The following will log such cases
    non-fatally.

    #+BEGIN_SRC emacs-lisp
      (defun jjin/use-package-if-prehook (name _keyword pred rest state)
        (if (not pred) (error "predicate failed; skipping package")))

      (advice-add 'use-package-handler/:if :before 'jjin/use-package-if-prehook)
    #+END_SRC
    
*** Baseline 

   #+BEGIN_SRC emacs-lisp
     (use-package diminish :straight t)

     (use-package names
       :straight t)

     (use-package system-packages
       :straight t
       :init
       (when (eq system-type 'darwin)
         (setq system-packages-package-manager 'brew)))
   #+END_SRC
    
** Functions

   #+BEGIN_SRC emacs-lisp
     (define-namespace jjin-
     (defun load-if-exists (file)
       "Loads file, conditional on its existence; no effect if non-existent."
       (when (file-exists-p file)
         (load-file file)))

     (defun kill-current-buffer ()
       (interactive)
       (kill-buffer (current-buffer)))

     (defun window-toggle-split-direction ()
       "Switch window split from horizontally to vertically, or vice versa.

     i.e. change right window to bottom, or change bottom window to right."
       (interactive)
       (require 'windmove)
       (let ((done))
         (dolist (dirs '((right . down) (down . right)))
           (unless done
             (let* ((win (selected-window))
                    (nextdir (car dirs))
                    (neighbour-dir (cdr dirs))
                    (next-win (windmove-find-other-window nextdir win))
                    (neighbour1 (windmove-find-other-window neighbour-dir win))
                    (neighbour2 (if next-win (with-selected-window next-win
                                               (windmove-find-other-window
                                                neighbour-dir next-win)))))

               (setq done (and (eq neighbour1 neighbour2)
                               (not (eq (minibuffer-window) next-win))))
               (if done
                   (let* ((other-buf (window-buffer next-win)))
                     (delete-window next-win)
                     (if (eq nextdir 'right)
                         (split-window-vertically)
                       (split-window-horizontally))
                     (set-window-buffer (windmove-find-other-window neighbour-dir)
                                        other-buf))))))))

     (defun insert-newline-after ()
       (interactive)
       (let ((oldpos (point)))
         (end-of-line)
         (newline-and-indent)
         (goto-char oldpos)))

     (defun set-opacity (value)
       "Sets the opacity of the frame window. 0=transparent/100=opaque"
       (interactive "nOpacity Value (0 - 100 opaque): ")
       (set-frame-parameter (selected-frame) 'alpha value))

     (defun dired-at-current ()
       (interactive)
       (dired default-directory))

     (defun prev-window ()
       (interactive)
       (other-window -1))

     ;; credit: https://gist.github.com/mads379/3402786
     ;; TODO: modeline indication
     ;; TODO: if maximized, prevent other window splitting (use minor mode?)
     (defun toggle-maximize-window ()
       "Maximize window"
       (interactive)
       (if (= 1 (length (window-list)))
           (jump-to-register '_)
         (progn
           (window-configuration-to-register '_)
           (delete-other-windows))))

     ;; credit: https://github.com/abo-abo/hydra/blob/master/hydra-examples.el
     (defun move-splitter-left (arg)
       "Move window splitter left."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'right))
           (shrink-window-horizontally arg)
         (enlarge-window-horizontally arg)))

     ;; credit: https://github.com/abo-abo/hydra/blob/master/hydra-examples.el
     (defun move-splitter-right (arg)
       "Move window splitter right."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'right))
           (enlarge-window-horizontally arg)
         (shrink-window-horizontally arg)))

     ;; credit: https://github.com/abo-abo/hydra/blob/master/hydra-examples.el
     (defun move-splitter-up (arg)
       "Move window splitter up."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'up))
           (enlarge-window arg)
         (shrink-window arg)))

     ;; credit: https://github.com/abo-abo/hydra/blob/master/hydra-examples.el
     (defun move-splitter-down (arg)
       "Move window splitter down."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'up))
           (shrink-window arg)
         (enlarge-window arg)))

     ;; TODO: set modeline
     (defun toggle-dedicated ()
       (interactive)
       (set-window-dedicated-p (selected-window)
                               (not (window-dedicated-p (selected-window)))))

     (defun bury-compile-buffer-if-successful (buffer string)
       "Bury a compilation buffer if succeeded without warnings "
       (if (and
            (string-match "compilation" (buffer-name buffer))
            (string-match "finished" string)
            (not
             (with-current-buffer buffer
               (search-forward "warning" nil t))))
           (run-with-timer 1 nil
                           (lambda (buf)
                             (bury-buffer buf)
                             (delete-window (get-buffer-window buf)))
                           buffer)))
     (defun get-current-displays ()
       "Get alist of attributes of displays w/ Emacs buffers."
       (require 'cl)
       (interactive)
       (remove-if
        (lambda (disp)
          (eq nil (cdr (assoc 'frames disp))))
        (display-monitor-attributes-list)))

     (defun fontify-frame ()
       (interactive)
       "Adjusts frame's text size according to current display's
     resolution. Prevents illegibly small text on high-resolution
     displays and, similarly, impractically large text on
     low-resolution displays."
       ;; FIXME: assumes only one emacs frame on one disp
       (let* ((curr-disp (car (jjin-get-current-displays)))
              (disp-width (nth 3 (assoc 'geometry curr-disp)))
              (font-name (if (eq system-type 'darwin) "Terminus (TTF)" "Terminus"))
              (font-size (if (> disp-width 2000) "12" "04")))
         (if (display-graphic-p)
             (set-frame-parameter nil 'font (string-join `(,font-name ,font-size) " "))))))
   #+END_SRC

* General Configurations

  #+BEGIN_SRC emacs-lisp
    (jjin-load-if-exists "~/.secrets.el")

    (setq ring-bell-function 'ignore)

    (setq large-file-warning-threshold nil)

    (setq
      user-mail-address "jjin082693@gmail.com"
      user-full-name  "Jonathan Jin")

    (setq
      inhibit-startup-screen t
      inhibit-startup-message t
      initial-scratch-message nil
      visible-bell t
      use-dialog-box nil)

    (setq-default
      fill-column 80
      indent-tabs-mode nil
      tab-width 4)

    (setq next-line-add-newlines t)

    (setq scroll-step 1
      scroll-conservatively 10000
      scroll-margin 3)

    (fset 'yes-or-no-p 'y-or-n-p)

    (if window-system
        (progn
          (tool-bar-mode     0)
          (scroll-bar-mode   0)
          (menu-bar-mode     0)
          (line-number-mode  0)))

    (blink-cursor-mode 0)

    (global-auto-revert-mode)
    (setq auto-revert-remote-files t)

    (global-hl-line-mode 1)
    (column-number-mode  1)
    (show-paren-mode     1)

    (electric-pair-mode)

    (delete-selection-mode +1)

    (add-hook 'prog-mode-hook 'turn-on-auto-fill)
    (add-hook 'text-mode-hook 'turn-on-auto-fill)

    (fringe-mode '(4 . 0))

    (with-eval-after-load 'dired
      (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file))

    (put 'dired-find-alternate-file 'disabled nil)

    (setq echo-keystrokes 0)

    (setq image-dired-external-viewer "feh")

    (setq term-ansi-default-program (getenv "SHELL"))

    (setq enable-remote-dir-locals t)

    (defconst custom-file-path "~/.emacs-custom.el")
    (if (file-exists-p custom-file-path)
        (load (setq custom-file custom-file-path)))
  #+END_SRC

** Scratch Org-mode

   I spend more time in Org-mode than I do writing Elisp.

   #+BEGIN_SRC emacs-lisp
     (setq initial-major-mode 'org-mode)
   #+END_SRC

** Appearance

*** Themes

    #+BEGIN_SRC emacs-lisp

      (use-package gotham-theme
        :if window-system
        :disabled t
        :config
        (load-theme 'gotham t)) 

      (use-package nord-theme
        :if window-system
        :straight (:host github :repo "arcticicestudio/nord-emacs" :branch "develop")
        :init
        (setq nord-comment-brightness 10)
        :config
        (load-theme 'nord t))
    #+END_SRC

*** General

    #+BEGIN_SRC emacs-lisp
      (setq-default x-stretch-cursor t)

      (setq custom-safe-themes t)

      (set-frame-font
       (cond 
        ((string= "gnu/linux" system-type) "-xos4-terminus-medium-r-normal--28-*-72-72-c-140-iso10646-1")
        ((string= "darwin" system-type) "Terminus (TTF) 16")
         (t "Terminus 16")))

      (when (functionp 'set-fontset-font)
        (set-fontset-font "fontset-default"
                          'unicode
                          (font-spec :family "DejaVu Sans Mono")))

      (jjin-set-opacity 90)
    #+END_SRC

** Environment-specific

*** Mac

    #+BEGIN_SRC emacs-lisp
      (when (eq system-type 'darwin)
        (setq mac-command-modifier 'meta)
        (setq mac-right-command-modifier 'meta)
        (setq mac-option-modifier 'super)
        (setq mac-right-option-modifier 'super)
        (setq system-uses-terminfo nil))
    #+END_SRC

    =compilation-mode= invokes shell in a non-interactive shell, which means
    that configurations in =.bashrc= do not get surfaced. This can cause
    complications in cases where, for instance, successful compilation is
    predicated on conditions set within a provisioned profile file that I do not
    control. When Bash is started non-interactively, it looks for =BASH_ENV= in
    the environment, expands its value if it appears there, and uses the
    expanded value as the name of a file to read and execute. As such, we set
    that environment value to our startup file here.

    #+begin_src emacs-lisp
      (when (eq system-type 'darwin) (setenv "BASH_ENV" "$HOME/.bashrc"))
    #+end_src
    

** Server

   Make sure =EDITOR= and/or =VISUAL= is/are set to =emacsclient=.

   #+BEGIN_SRC emacs-lisp
     (use-package server
       :config
       (unless (server-running-p) (server-start)))
   #+END_SRC
   
** "Launcher"

   I like to keep several functions within Emacs within a short key press away;
   these tend to correspond to "applications" such as email, RSS, Slack,
   etc.

   The following allows me to emulate [[https://en.wikipedia.org/wiki/Spotlight_(software)][macOS's Spotlight functionality]] in a
   lightweight manner, to put these regularly used "applications" within easy
   reach.

   #+begin_src emacs-lisp
     (use-package helm-exec
       :after helm
       :straight (:repo "https://github.com/jinnovation/helm-exec.git")
       :bind (("C-c e" . helm-exec-execute)))
   #+end_src
  
** Nested .dir-locals.el

   #+begin_src emacs-lisp
     (use-package nested-dir-local
       :straight (:repo "git@github.com:jinnovation/nested-dir-locals.el.git"))
   #+end_src
* Keys

** Personal maps

   #+BEGIN_SRC emacs-lisp
     (define-prefix-command 'jjin-vc-map)
     (bind-key "C-c v" 'jjin-vc-map)

     (define-prefix-command 'jjin-chat-map)
     (bind-key "C-c i" 'jjin-chat-map)

     (define-prefix-command 'jjin-comment-map)
     (bind-key "C-c c" 'jjin-comment-map)

     (define-prefix-command 'jjin-term-map)
     (bind-key "C-c t" 'jjin-term-map)

     (define-prefix-command 'jjin-buffer-map)
     (bind-key "C-c b" 'jjin-buffer-map)
   #+END_SRC

** Keybindings

   #+BEGIN_SRC emacs-lisp
     (bind-keys :map global-map
                ("C-x k"              . jjin-kill-current-buffer)
                ("RET"                . newline-and-indent))

     (unbind-key "<menu>")
     (unbind-key "M-`")
     (unbind-key "C-c C-w")
     (unbind-key "C-x C-n")      ; set-goal-column

     (unbind-key "<f10>")
     (unbind-key "<f11>")
     (unbind-key "M-<f10>")
     (unbind-key "<escape> <f10>")

     (bind-keys :map jjin-buffer-map
                ("r" . rename-buffer))

     (bind-keys :map global-map
                ("<s-backspace>" . backward-kill-word))

     (bind-keys :map global-map
                ("s-s" . save-buffer))

     (use-package org-src
       :bind (("s-s" . org-edit-src-save)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package hydra
       :commands defhydra
       :straight t
       :config
       (defhydra jjin-hydra-window (global-map "C-c w")
         "Commands relating to window manipulation"
         ("h" windmove-left "move left")
         ("l" windmove-right "move right")
         ("j" windmove-down "move down")
         ("k" windmove-up "move up")
         ("q" delete-window "delete window")
         ("Q" kill-buffer-and-window "kill buffer, delete window")
         ("H" jjin-move-splitter-left "move splitter left")
         ("L" jjin-move-splitter-right "move splitter right")
         ("J" jjin-move-splitter-down "move splitter down")
         ("K" jjin-move-splitter-up "move splitter up")
         ("b" balance-windows)
         ("|" jjin-window-toggle-split-direction)
         ("s" split-window-below "split window (below)")
         ("v" split-window-right "split window (right)")
         (";" ace-window "select window" :exit t)))
   #+END_SRC

* Development Environments

** General Style

   #+BEGIN_SRC emacs-lisp
     (c-set-offset 'arglist-intro '+)
     (c-set-offset 'arglist-close 0)
   #+END_SRC

** Aurora

   #+begin_src emacs-lisp
     (use-package aurora-config-mode
       :straight t)
   #+end_src

** C/C++

   #+BEGIN_SRC emacs-lisp
     (setq c-block-comment-prefix "* ")

     (defvaralias 'c-basic-offset 'tab-width)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package irony
       :disabled t
       :commands irony-mode
       :init
       (add-hook 'c-mode-hook 'irony-mode)
       (add-hook 'c++-mode-hook 'irony-mode)
       :config
       (use-package flycheck-irony
         :config
         (add-hook 'flycheck-mode-hook 'flycheck-irony-setup)))

     (use-package company-irony
       :disabled t
       :config
       (add-to-list 'company-backends 'company-irony))

     (use-package clang-format
       :disabled t
       :config
       (add-to-list 'auto-mode-alist '("\\.clang-format$" . yaml-mode)))
   #+END_SRC

** Go

   #+BEGIN_SRC emacs-lisp
     (use-package go-mode
       :mode "\\.go$"
       :straight t

       :init
       (if (executable-find "goimports")
           (setq gofmt-command "goimports")
         (message "Goimports not found; using default `gofmt-command'"))

       :config
       (add-hook 'before-save-hook 'gofmt-before-save))

     (use-package company-go
       :after go
       :disabled t)

     (use-package go-guru
       :after go
       :straight t)
   #+END_SRC

** Lisp

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("emacs$" . emacs-lisp-mode))
     (add-to-list 'auto-mode-alist '("Cask" . emacs-lisp-mode))
   #+END_SRC

** Javascript

   #+BEGIN_SRC emacs-lisp
     (defvaralias 'js-indent-level 'tab-width)

     (use-package js2-mode
       :mode (("\\.js$" . js2-mode)
              ("\\.jsx$" . js2-jsx-mode))
       :straight t)

     (use-package json-mode
       :straight t)
   #+END_SRC

** LaTeX

   #+BEGIN_SRC emacs-lisp
     ;; sets latex-mode to compile w/ pdflatex by default
     (setq TeX-PDF-mode t
         TeX-parse-self t
         TeX-newline-function 'reindent-then-newline-and-indent)

     (eval-after-load "tex"
         '(setcdr (assoc "LaTeX" TeX-command-list)
              '("%`%l%(mode) -shell-escape%' %t"
                   TeX-run-TeX nil (latex-mode doctex-mode) :help "Run LaTeX")))

     ;; latex-mode-specific hooks (because latex-mode is not derived from prog-mode)
     (add-hook 'LaTeX-mode-hook
         (lambda ()
             (TeX-fold-mode 1)
             (auto-fill-mode)
             (add-to-list 'TeX-command-list '("XeLaTeX" "%`xelatex%(mode)%' %t"
                                                 TeX-run-TeX nil t))))
   #+END_SRC

** zsh

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("zshrc$" . sh-mode))
     (add-to-list 'auto-mode-alist '("\\.zsh$" . sh-mode))
   #+END_SRC

** Haskell

   #+BEGIN_SRC emacs-lisp
     (use-package haskell-mode
       :disabled t
       :config
       (add-hook 'haskell-mode-hook 'turn-on-haskell-indent))
   #+END_SRC

** Pants

   #+begin_src emacs-lisp
     (use-package pants-build-mode
       :mode ("BUILD$")
       :straight (:repo "git@github.com:jinnovation/pants-build-mode.git"))
   #+end_src
   
** Ruby

   #+BEGIN_SRC emacs-lisp
     (use-package enh-ruby-mode
       :disabled t
       :mode ("Gemfile" "Guardfile")
       :config
       (defvaralias 'ruby-indent-level 'tab-width))

     (use-package ruby-end
       :disabled t
       :config
       (add-hook 'ruby-mode-hook 'ruby-end-mode))
   #+END_SRC

** SQL

   #+BEGIN_SRC emacs-lisp
     (setq sql-mysql-options '("--local-infile"))

     (add-hook 'sql-interactive-mode-hook
               (lambda ()
                 (toggle-truncate-lines t)))
   #+END_SRC

** Thrift

   #+BEGIN_SRC emacs-lisp
     (use-package thrift
       :straight t
       :if (eq system-type 'darwin) ;; only need this on work computer
       :config
       (add-hook 'thrift-mode-hook
                 (lambda ()
                   (setq comment-start "//")
                   (setq comment-end ""))))
   #+END_SRC

** Octave

   #+BEGIN_SRC emacs-lisp
     (use-package octave
       :mode ("\\.m$" . octave-mode)
       :interpreter ("octave" . octave-mode)
       :config
       (with-eval-after-load 'evil
           (progn
             (add-to-list 'evil-emacs-state-modes 'octave-help-mode)
             (add-to-list 'evil-emacs-state-modes 'inferior-octave-mode)))

       (setq inferior-octave-program "octave-cli")
       (setq inferior-octave-prompt ">> ")
       (setq inferior-octave-dynamic-complete-functions '(comint-filename-completion))

       (setq inferior-octave-startup-args '("-i" "--line-editing" "-q" "--traditional")))
   #+END_SRC

** Matlab

   #+BEGIN_SRC emacs-lisp
     (use-package matlab
       :disabled t
       :init
       (setq matlab-shell-command-switches '("-nodesktop")))
   #+END_SRC

** Python

   #+BEGIN_SRC emacs-lisp
     (setq python-fill-docstring-style 'pep-257)

     (use-package pyvenv
       :straight t)

     (use-package elpy
       :straight t
       :init
       (setq elpy-modules '(elpy-module-company
                            elpy-module-eldoc
                            elpy-module-flymake
                            elpy-module-pyvenv
                            elpy-module-yasnippet
                            elpy-module-sane-defaults))
       (elpy-enable))
   #+END_SRC

** Emacs Lisp

   #+BEGIN_SRC emacs-lisp
     (use-package elisp-mode
       :bind (("C-c C-f" . find-function)
              ("C-c C-v" . find-variable)))
   #+END_SRC

** Markdown

   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :straight t
       :mode "\\.md$"
       :init
       (setq markdown-asymmetric-header t)
       :config
       (add-hook 'markdown-mode-hook 'auto-fill-mode))

     (use-package markdown-mode+
       :straight t
       :after markdown-mode)
   #+END_SRC

** YAML

   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode
       :straight t
       :mode "\\.yaml$")
   #+END_SRC

** Twitter

   #+begin_src emacs-lisp
     (with-eval-after-load 'projectile
       (projectile-register-project-type 'twitter-source-sub '(".pants.d")
                                         :compilation-dir "~/workspace/source/"
                                         :compile "./pants "
                                         :test "./pants test "
                                         :run "./pants "))
     (use-package twitter-source
       :straight (:local-repo "~/workspace/twitter-source.el"))
   #+end_src
   
** Scala

   #+begin_src emacs-lisp
     (use-package scala-mode
       :straight t)
   #+end_src
   
* General Packages

** =ace-link=

   #+BEGIN_SRC emacs-lisp
     (use-package ace-link
       :straight t
       :commands (ace-link-eww ace-link-setup-default)
       :init (ace-link-setup-default))
   #+END_SRC

** =ace-window=

   #+BEGIN_SRC emacs-lisp
     (use-package ace-window
       :commands ace-window
       :straight t
       :init
       (setq aw-keys '(?a ?r ?s ?t ?q ?w ?f ?p))

       :config
       ;; technically should be able to use mu4e~update-name but for whatever reason
       ;; the mu4e update index function uses the hardcoded string w/ space padding.
       (add-to-list 'aw-ignored-buffers " *mu4e-update*"))
   #+END_SRC

** =ansi-color=

   #+BEGIN_SRC emacs-lisp
     (use-package ansi-color
       :init
       (setq ansi-color-faces-vector
         [default bold shadow italic underline bold bold-italic bold])
       (setq compilation-scroll-output t)
       :config
       (defun colorize-compilation-buffer ()
         (toggle-read-only)
         (ansi-color-apply-on-region (point-min) (point-max))
         (toggle-read-only))

       (add-hook 'compilation-filter-hook 'colorize-compilation-buffer))
   #+END_SRC

** =browse-url=

   #+BEGIN_SRC emacs-lisp
     (use-package browse-url
       :config
       (setq browse-url-browser-function
             (if (browse-url-can-use-xdg-open) 'browse-url-xdg-open
               'browse-url-default-browser))

       ;; FIXME: regex search for chromium (some distros package the name differently)
       (setq browse-url-generic-program
             (if (eq system-type 'darwin)
                 "open"
               (executable-find "chromium-browser")))

       (setq shr-external-browser 'browse-url-generic))
   #+END_SRC

** =calc=

   #+BEGIN_SRC emacs-lisp
     (use-package calc
       :init
       (with-eval-after-load 'helm-exec
         (helm-exec-register-executable 'calc)))
   #+END_SRC

** =conf-mode=

   #+BEGIN_SRC emacs-lisp
     (use-package conf-mode
       :mode
       (;; systemd
         ("\\.service\\'"     . conf-unix-mode)
         ("\\.timer\\'"      . conf-unix-mode)
         ("\\.target\\'"     . conf-unix-mode)
         ("\\.mount\\'"      . conf-unix-mode)
         ("\\.automount\\'"  . conf-unix-mode)
         ("\\.slice\\'"      . conf-unix-mode)
         ("\\.socket\\'"     . conf-unix-mode)
         ("\\.path\\'"       . conf-unix-mode)

         ;; general
         ("conf\\(ig\\)?$"   . conf-mode)
         ("rc$"              . conf-mode)))

   #+END_SRC

** =company=

   #+BEGIN_SRC emacs-lisp
     (use-package company
       :defines company-backends
       :diminish company-mode
       :straight t
       :config
       (add-hook 'after-init-hook 'global-company-mode)
       (setq company-idle-delay 0.1))
   #+END_SRC

** =dired=

   #+BEGIN_SRC emacs-lisp
     (setq dired-listing-switches "-alh")

     (use-package dired-open
       :straight t
       :init
       (setq dired-open-extensions '(("mp4" . "vlc")
                                     ("avi" . "vlc"))))
   #+END_SRC

** =doc-view-mode=

   #+BEGIN_SRC emacs-lisp
     (use-package doc-view
       :init
       (setq doc-view-resolution 200))
   #+END_SRC

** =ediff=

   #+BEGIN_SRC emacs-lisp
     (use-package ediff
       :init
       (setq ediff-window-setup-function 'ediff-setup-windows-plain))
   #+END_SRC

** =exec-path-from-shell=

   #+BEGIN_SRC emacs-lisp
     (use-package exec-path-from-shell
       :straight t
       :config
       (exec-path-from-shell-initialize))
    #+END_SRC

** Elfeed

   #+BEGIN_SRC emacs-lisp
     (use-package elfeed
       :straight t
       :commands elfeed
       :bind (:map elfeed-search-mode-map
              ("<SPC>" . next-line)
              ("U" . elfeed-unjam)
              :map elfeed-show-mode-map
              ("S-<SPC>" . scroll-down-command))

       :init
       (with-eval-after-load 'helm-exec
         (helm-exec-register-executable 'elfeed 'elfeed))

       (setq elfeed-use-curl t)
       (setq elfeed-log-level 'debug)

       :config
       (with-eval-after-load 'evil
         (add-to-list 'evil-emacs-state-modes 'elfeed-search-mode)
         (add-to-list 'evil-emacs-state-modes 'elfeed-show-mode))

       (set-face-attribute 'elfeed-search-feed-face
                           nil
                           :foreground (face-attribute 'warning :foreground))

       (set-face-attribute 'elfeed-search-tag-face
                           nil
                           :foreground (face-attribute 'success :foreground))

       (set-face-attribute 'elfeed-search-unread-title-face
                           nil
                           :weight 'normal
                           :foreground (face-attribute 'default :foreground))

       (set-face-attribute 'elfeed-search-title-face
                           nil
                           :foreground (face-attribute 'font-lock-comment-face :foreground)))

     (use-package elfeed-protocol
       :disabled t
       :after elfeed
       :straight (:host github
                  :type git
                  :repo "fasheng/elfeed-protocol"
                  :fork (:host github :repo "jinnovation/elfeed-protocol" :branch "master"))

       :if (-all-p 'boundp '(jjin/secret/ttrss-domain
                             jjin/secret/ttrss-username
                             jjin/secret/ttrss-pass))
       :init
       (setq elfeed-feeds
             (list (format "ttrss+http://%s:%s@%s" jjin/secret/ttrss-username jjin/secret/ttrss-pass jjin/secret/ttrss-domain)))

       (setq elfeed-protocol-ttrss-categories-as-tags t)

       :config
       (elfeed-protocol-enable))
   #+END_SRC
   
** Eshell

   #+BEGIN_SRC emacs-lisp
     ;; From: https://www.emacswiki.org/emacs/EshellPrompt
     (defun shortened-path (path max-len)
           "Return a modified version of `path', replacing some components
           with single characters starting from the left to try and get
           the path down to `max-len'"
           (let* ((components (split-string (abbreviate-file-name path) "/"))
                  (len (+ (1- (length components))
                          (reduce '+ components :key 'length)))
                  (str ""))
             (while (and (> len max-len)
                         (cdr components))
               (setq str (concat str (if (= 0 (length (car components)))
                                         "/"
                                       (string (elt (car components) 0) ?/)))
                     len (- len (1- (length (car components))))
                     components (cdr components)))
             (concat str (reduce (lambda (a b) (concat a "/" b)) components))))

     (use-package eshell
       :init
       (setq eshell-rc-script (concat user-emacs-directory "eshell/profile"))
       (setq eshell-modify-global-environment t)
       (setq eshell-banner-message "")

       :config
       (with-eval-after-load 'evil
         (delete 'eshell-mode evil-insert-state-modes)
         (add-to-list 'evil-emacs-state-modes 'eshell-mode))

       (bind-keys :map jjin-term-map
                  ("e" . eshell))

       (defun eshell/la (&rest args)
         (eshell/ls "--almost-all" "-l" args))

       (with-eval-after-load 'magit
         (setq eshell-prompt-function
               (lambda ()
                 (concat
                  (propertize "┌─[" 'face 'font-lock-string-face)
                  (propertize (user-login-name) 'face 'font-lock-function-name-face)
                  (propertize "@" 'face 'font-lock-string-face)
                  (when-let ((b (magit-get-current-branch)))
                    (propertize b 'face `(:foreground "yellow")))
                  (when (magit-anything-modified-p)
                    (propertize "*" 'face `(:foreground "yellow")))
                  (propertize "]──[" 'face 'font-lock-string-face)
                  (propertize (format-time-string "%H:%M:%S" (current-time)) 'face 'font-lock-keyword-face)
                  (propertize "]──[" 'face 'font-lock-string-face)
                  (propertize (shortened-path (eshell/pwd) 40) 'face `(:foreground "white"))
                  (propertize "]\n" 'face 'font-lock-string-face)
                  (propertize "└─>" 'face 'font-lock-string-face)
                  (propertize (if (= (user-uid) 0) " #" " $") 'face 'font-lock-string-face)
                  " "
                  )))))
   #+END_SRC
   
*** Initialization file

    #+BEGIN_SRC emacs-lisp :tangle eshell/profile
    (setenv "EDITOR" "emacsclient")
    #+END_SRC

** =ess=

   #+BEGIN_SRC emacs-lisp
     (use-package ess-site
       :disabled t
       :ensure ess
       :commands (inferior-ess-mode ess-help-mode)
       :init
       (setq inferior-R-args "--quiet")

       :config
       (with-eval-after-load 'evil
           (progn
             (add-to-list 'evil-emacs-state-modes 'inferior-ess-mode)
             (add-to-list 'evil-emacs-state-modes 'ess-help-mode)))
       (bind-key "C-c C-w" nil inferior-ess-mode-map))
   #+END_SRC

** Evil (base + extras)

   #+BEGIN_SRC emacs-lisp
     (use-package evil
       :straight t
       :defines evil-normal-state-map
       :init
       (setq evil-esc-delay 0)

       :config
       (mapc (lambda (m) (add-to-list 'evil-emacs-state-modes m t))
         '(eshell-mode
            calendar-mode

            finder-mode
            info-mode

            eww-mode
            eww-bookmark-mode

            dired-mode
            image-mode
            image-dired-thumbnail-mode
            image-dired-display-image-mode

            git-rebase-mode

            help-mode

            sql-interactive-mode
            org-capture-mode))
       ;; FIXME: what's the diff between set-initial-state and adding to list directly?
       (evil-set-initial-state 'term-mode 'emacs)

       (bind-keys :map evil-emacs-state-map
         ("<escape>" . evil-execute-in-normal-state))

       (evil-mode 1))

     (use-package evil-numbers
       :after evil
       :straight t
       :config
       (bind-keys :map evil-normal-state-map
                  ("C-a"   . evil-numbers/inc-at-pt)
                  ("C-c -" . evil-numbers/dec-at-pt)))

     (use-package evil-search-highlight-persist
       :after evil
       :straight t
       :config
       (bind-key "C-l" 'evil-search-highlight-persist-remove-all
                 evil-normal-state-map)
       (global-evil-search-highlight-persist t)

       (set-face-attribute
        'evil-search-highlight-persist-highlight-face
        nil
        :background (face-attribute 'match :background)))

     (use-package evil-surround
       :after evil
       :straight t
       :config
       (global-evil-surround-mode 1))

     (use-package evil-nerd-commenter
       :after evil
       :straight t
       :config
       (bind-keys :map jjin-comment-map
                  ("i" . evilnc-comment-or-uncomment-lines)
                  ("l" . evilnc-quick-comment-or-uncomment-to-the-line)
                  ("c" . evilnc-copy-and-comment-lines)
                  ("p" . evilnc-comment-or-uncomment-paragraphs)
                  ("v" . evilnc-toggle-invert-comment-line-by-line)))

   #+END_SRC

** =fill-column-indicator=

   #+BEGIN_SRC emacs-lisp
     (use-package fill-column-indicator
       :commands turn-on-fci-mode
       :straight t
       :disabled t
       :init
       (add-hook 'prog-mode-hook 'turn-on-fci-mode)
       (add-hook 'text-mode-hook 'turn-on-fci-mode)
       (setq fci-rule-color (face-attribute 'highlight :background)))
   #+END_SRC

** =flycheck=

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :disabled t
       :defines flycheck-mode-hook
       :config
       (add-hook 'after-init-hook #'global-flycheck-mode))
   #+END_SRC

** Git

   #+BEGIN_SRC emacs-lisp
     (bind-keys :map jjin-vc-map
                ("g" . vc-git-grep))

     (setq vc-handled-backends nil)
   #+END_SRC

*** =git-commit-mode=

    #+BEGIN_SRC emacs-lisp
      (use-package git-commit-mode
        :commands git-commit-mode)
    #+END_SRC

*** =gitconfig-mode=
    #+BEGIN_SRC emacs-lisp
      (use-package gitconfig-mode
        :straight t
        :mode "gitconfig")
    #+END_SRC

*** =gitignore-mode=

    #+BEGIN_SRC emacs-lisp
      (use-package gitignore-mode
        :straight t
        :mode "gitignore")
    #+END_SRC

*** Magit

    Merge commits can sometimes be massive -- particularly in monorepo
    environments. Since showing the diff during commit in such scenarios is of
    questionable utility, we suppress its behavior with the following advice.

    #+begin_src emacs-lisp
      (defun jjin/do-if-merge-not-in-progress (oldfun)
        "Displays the diff during commit only in cases where a merge is
        not in progress."
        (when (not (magit-merge-in-progress-p)) (funcall oldfun)))

      (defun jjin/magit-fetch-from-origin-master ()
        (interactive)
        (magit-git-fetch "origin" "master"))

      (defun jjin/magit-checkout-previous-branch ()
        (interactive)
        (if-let ((p (magit-get-previous-branch)))
            (magit-checkout p)
          (error "No previous branch")))
    #+end_src

    #+BEGIN_SRC emacs-lisp
      ;; TODO: Magit has migrated to using transient, so all commented sections will
      ;; eventually need to be updated or removed.

      (use-package transient
        :straight t
        :init
        (setq transient-show-common-commands nil))

      (use-package magit
        :straight t
        :init

        (add-to-list
         'safe-local-variable-values
         '(magit-status-headers-hook . (list
                                        magit-insert-error-header
                                        magit-insert-diff-filter-header
                                        magit-insert-head-branch-header
                                        magit-insert-upstream-branch-header
                                        magit-insert-push-branch-header)))

        (setq magit-log-arguments '("--graph"
                                    "--decorate"
                                    "--color"))

        (setq magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)

        :config
        (bind-keys :map jjin-vc-map
                   ("!" . magit-git-command-topdir)
                   ("C" . magit-branch-and-checkout)
                   ("F" . magit-pull)
                   ("P" . magit-push)
                   ("b" . magit-blame)
                   ("c" . magit-checkout)
                   ("d" . magit-diff)
                   ("f" . magit-fetch)
                   ("l" . magit-log)
                   ("m" . magit-merge)
                   ("v" . magit-status)
                   ("z" . magit-stash))

        (with-eval-after-load 'git-rebase
          (bind-keys :map git-rebase-mode-map ("u" . git-rebase-undo)))

        (bind-keys :map magit-mode-map
                   ("X" . magit-reset-hard))

        ;; removes 1.4.0 warning in arguably cleaner way
        (remove-hook 'after-init-hook 'magit-maybe-show-setup-instructions)

        (defadvice magit-blame-mode (after switch-to-emacs-state activate)
          (if magit-blame-mode
              (evil-emacs-state 1)
            (evil-normal-state 1)))

        (with-eval-after-load 'evil
          (add-to-list 'evil-emacs-state-modes 'magit-popup-mode))

        (add-hook 'magit-revision-mode-hook 'goto-address-mode)

        (transient-append-suffix 'magit-commit 'magit-commit:--reuse-message
          '("-m"
            "Attach message"
            "--message="
            :prompt "Message"
            :reader magit-read-string))

        ;; (magit-define-popup-action 'magit-diff-popup ?U
        ;;   "Diff upstream"
        ;;   (lambda (&optional args files)
        ;;     (interactive (magit-diff-arguments))
        ;;     (magit-diff  "@{u}..HEAD" args)))


        (defun jjin/magit-find-file-from-upstream (file)
          "Same behavior as `magit-find-file', but specifically for the
      upstream branch."
          (interactive
           (list (magit-read-file-from-rev (magit-get-upstream-branch) "Find file")))
          (magit-find-file (magit-get-upstream-branch) file))

        )

        ;; (plist-put magit-merge-popup :actions (cons "Actions" (plist-get magit-merge-popup :actions)))
        ;; (plist-put magit-merge-popup
        ;;            :actions
        ;;            (cons '(?U "Upstream" (lambda (ignored &optional args)
        ;;                                    (interactive (magit-diff-arguments))
        ;;                                    (magit-merge "@{u}" args)))
        ;;                  (plist-get magit-merge-popup :actions)))

        ;; (plist-put
        ;;  magit-merge-popup
        ;;  :actions
        ;;  (cons
        ;;   (lambda ()
        ;;     (concat (propertize "Merge into " 'face 'magit-popup-heading)
        ;;             (propertize (or (magit-get-current-branch) "HEAD") 'face 'magit-branch-local)
        ;;             (propertize " from" 'face 'magit-popup-heading)))
        ;;   (plist-get magit-merge-popup :actions)))

        ;; (magit-define-popup-action 'magit-fetch-popup
        ;;   ?U "from origin/master" 'jjin/magit-fetch-from-origin-master)

        ;; (magit-define-popup-action 'magit-branch-popup
        ;;   ?P
        ;;   (lambda ()
        ;;     (if-let ((p (magit-get-previous-branch)))
        ;;         "Checkout previous branch"
        ;;       "No previous branch"))
        ;;   'jjin/magit-checkout-previous-branch))

        ;; (advice-add 'magit-commit-diff
        ;;             :before-until
        ;;             'magit-merge-in-progress-p))

      (use-package magit-arcanist
        :after magit
        :straight (:repo "git@github.com:jinnovation/magit-arcanist.git")
        :init
        (setq magit-arcanist-key (kbd "@"))
        :bind (:map jjin-vc-map
               ("a" . magit-arcanist-popup))
        :config
        (magit-arcanist-enable))
    #+END_SRC
    
** =helm=

   #+BEGIN_SRC emacs-lisp
     (use-package helm
       :straight t
       :demand t
       :diminish helm-mode
       :bind (("C-x m"    . helm-M-x)
              ("C-x C-f" . helm-find-files)
              ("C-x b"   . helm-buffers-list))
       :init
       (setq helm-external-programs-associations `(("pdf" . ,(if (eq system-type 'darwin) "open" "zathura"))))
       (setq helm-split-window-inside-p t)

       (setq helm-mode-fuzzy-match t)

       :config
       (helm-mode 1)
       (helm-autoresize-mode t)

       (defvar helm-source-file-not-found
         (helm-build-dummy-source
             "Create file"
           :action
           (lambda (c) (find-file c))))

       (bind-keys :map jjin-vc-map
                  ("g" . helm-grep-do-git-grep))

       ;; (bind-key "C-c C-j" 'helm-org-in-buffer-headings org-mode-map)

       (setq helm-ff-candidate-number-limit 500)
       )

     (use-package helm-make
       :straight t
       :commands helm-make-projectile
       :init
       (setq helm-make-cache-targets t)
       (setq helm-make-list-target-method 'qp))

     (use-package helm-projectile
       :after projectile
       :bind (:map projectile-command-map
                   ("p"   . helm-projectile)
                   ("a"   . helm-projectile-find-other-file)
                   ("f"   . helm-projectile-find-file)
                   ("F"   . helm-projectile-find-file-in-known-projects)
                   ("s s" . helm-projectile-ag)
                   ("s g" . helm-projectile-grep))
       :straight t
       :config
       (add-to-list 'helm-projectile-sources-list helm-source-file-not-found t))
   #+END_SRC

** =linum=

   #+BEGIN_SRC emacs-lisp
     (use-package linum
       :straight t
       :config
       (setq linum-format 'dynamic)
       (global-linum-mode 1)

       (defconst linum-mode-whitelist
         '(prog-mode))

       (require 'mode-local)

       (defadvice linum-mode (around linum-mode-selective activate)
         "Avoids enabling of linum-mode in the buffer having major mode set to one
     of listed in `linum-mode-excludes'."
         (if (or (member major-mode linum-mode-whitelist)
                 (member (get-mode-local-parent major-mode) linum-mode-whitelist))
           ad-do-it)))
   #+END_SRC

** =multi-term=

   #+BEGIN_SRC emacs-lisp
     (use-package multi-term
       :straight t
       :config
       (bind-keys :map jjin-term-map
                  ("t" . multi-term)
                  ("n" . multi-term-next)
                  ("p" . multi-term-prev)
                  ("d" . multi-term-dedicated-toggle))

       (setq term-bind-key-alist
             '(("C-c C-k" . term-line-mode)
               ("M-]" . multi-term-next)
               ("M-[" . multi-term-prev)
               ("C-c C-c" . term-interrupt-subjob)
               ("C-c C-e" . term-send-esc)
               ("C-m" . term-send-return)
               ("C-y" . term-paste)
               ("M-f" . term-send-forward-word)
               ("M-b" . term-send-backward-word)
               ("M-o" . term-send-backspace)
               ("M-p" . term-send-up)
               ("M-n" . term-send-down)
               ("M-M" . term-send-forward-kill-word)
               ("M-N" . term-send-backward-kill-word)
               ("<M-backspace>" . term-send-backward-kill-word)
               ("M-r" . term-send-reverse-search-history)
               ("M-," . term-send-raw)
               ("M-." . comint-dynamic-complete))))
   #+END_SRC

** =mu4e=

   #+BEGIN_SRC emacs-lisp
     (use-package mu4e
       :ensure-system-package
       ((mu . mu)
        (offlineimap . offlineimap)
        (w3m . w3m))
       :commands (mu4e mu4e-update-mail-and-index)
       :init
       (defhydra jjin-hydra-mu4e (:exit t)
         "Auxiliary commands for mu4e"
         ("m" mu4e-update-mail-and-index "update"))

       (with-eval-after-load 'helm-exec
         (helm-exec-register-executable 'mu4e
                                        :alt 'jjin-hydra-mu4e/body))

       (setq mu4e-context-policy 'pick-first)
       (setq mu4e-headers-include-related nil)

       :config
       (when (eq system-type 'darwin)
         (setq mu4e-mu-binary "/usr/local/bin/mu"))

       ;; make sure the gnutls command line utils are installed
       ;; (require 'smtpmail)

       (setq
        message-send-mail-function 'smtpmail-send-it
        smtpmail-stream-type 'starttls
        smtpmail-default-smtp-server "smtp.gmail.com"
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587)

       (setq
        mu4e-maildir "~/mail"

        mu4e-drafts-folder "/personal/drafts"
        mu4e-sent-folder   "/personal/sent")

       ;; don't save message to Sent Messages, Gmail/IMAP takes care of this
       ;; (See the documentation for `mu4e-sent-messages-behavior' if you have
       ;; additional non-Gmail addresses and want assign them different
       ;; behavior.)
       (setq mu4e-sent-messages-behavior 'delete)

       (setq mu4e-maildir-shortcuts
             '(("/personal/INBOX"   . ?i)
               ("/personal/sent"    . ?s)
               ("/personal/drafts"  . ?d)
               ("/personal/archive" . ?a)
               ("/work/INBOX" . ?I)
               ("/work/sent" . ?S)
               ("/work/drafts" . ?D)
               ("/work/archive" . ?A)))

       (setq mu4e-get-mail-command
             (if (not (executable-find "offlineimap"))
                 "true" 
               "offlineimap"))

       ;; don't keep message buffers around
       (setq message-kill-buffer-on-exit t)

       (setq
        ;; FIXME: if w3m not installed:
        ;; - log it
        ;; - leave as default
        mu4e-html-renderer 'w3m
        mu4e-html2text-command "w3m -dump -T text/html")

       (add-hook 'mu4e-view-mode-hook 'visual-line-mode)

       (use-package gnus-dired
         :config
         ;; make the `gnus-dired-mail-buffers' function also work on message-mode derived
         ;; modes, such as mu4e-compose-mode
         (defun gnus-dired-mail-buffers ()
           (let (buffers)
             (save-current-buffer
               (dolist (buffer (buffer-list t))
                 (set-buffer buffer)
                 (when (and (derived-mode-p 'message-mode)
                            (null message-sent-message-via))
                   (push (buffer-name buffer) buffers))))
             (nreverse buffers)))

         (setq gnus-dired-mail-mode 'mu4e-user-agent)
         (add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode))

       (set-face-attribute 'mu4e-header-highlight-face nil :underline nil)

       (setq mu4e-compose-signature-auto-include nil)

       (setq mail-user-agent 'mu4e-user-agent)

       (add-to-list 'mu4e-view-actions
                    '("View in browser" . mu4e-action-view-in-browser)
                    t)
       (add-to-list 'mu4e-view-actions
                    '("Capture message" . mu4e-action-capture-message)
                    t)

       (setq mu4e-update-interval nil)
       (setq mu4e-headers-skip-duplicates t)
       (setq mu4e-view-show-images t)

       (defun mu4e-message-maildir-matches (msg rx)
         (when rx
           (if (listp rx)
               ;; if rx is a list, try each one for a match
               (or (mu4e-message-maildir-matches msg (car rx))
                   (mu4e-message-maildir-matches msg (cdr rx)))
             ;; not a list, check rx
             (string-match rx (mu4e-message-field msg :maildir)))))

       (setq mu4e-contexts
             `(,(make-mu4e-context
                 :name "personal"
                 :match-func
                 (lambda (msg)
                   (when msg
                     (or
                      (mu4e-message-maildir-matches msg "^/personal")
                      (mu4e-message-contact-field-matches msg :to "jjin082693@gmail.com"))))
                 :vars `((user-mail-address . "jjin082693@gmail.com")
                         (mu4e-compose-signature
                          . ,(concat "Jonathan Jin\n"
                                     "Machine Learning Software Engineer, Twitter Cortex\n"
                                     "jjin.info"))
                         (smtpmail-smtp-user . "jjin082693@gmail.com")
                         (user-full-name . "Jonathan Jin")
                         (mu4e-trash-folder . "/personal/trash")
                         (mu4e-drafts-folder . "/personal/drafts")
                         (mu4e-refile-folder . "/personal/archive")))

                  ,(make-mu4e-context
                    :name "work"
                    :match-func
                    (lambda (msg)
                      (when msg
                        (or
                         (mu4e-message-maildir-matches msg "^/work")
                         (mu4e-message-contact-field-matches msg :to "jonathanj@twitter.com"))))
                    :vars `((user-mail-address . "jonathanj@twitter.com")
                            (mu4e-compose-signature
                             . ,(concat "Jonathan Jin\n"
                                        "Software Engineer, ML Platform Tools, Cortex"))
                            (smtpmail-smtp-user . "jonathanj@twitter.com")
                            (user-full-name . "Jonathan Jin")
                            (mu4e-trash-folder . "/work/trash")
                            (mu4e-drafts-folder . "/work/drafts")
                            (mu4e-refile-folder . "/work/archive")))))

       (setq mu4e-compose-context-policy 'ask)

       ;; Sets `mu4e-user-mail-address-list' to the concatenation of all
       ;; `user-mail-address' values for all contexts. If you have other mail
       ;; addresses as well, you'll need to add those manually.
       (setq mu4e-user-mail-address-list
             (delq nil
                   (mapcar (lambda (context)
                             (when (mu4e-context-vars context)
                               (cdr (assq 'user-mail-address (mu4e-context-vars context)))))
                           mu4e-contexts)))

       (setq mu4e-view-show-addresses t)

       (add-to-list 'mu4e-bookmarks
                    '("(maildir:\"/personal/INBOX\" OR maildir:\"/work/INBOX\") flag:unread"
                      "Unread INBOXes"
                      ?U)
                    t)

       (add-hook 'mu4e-view-mode-hook 'mu4e-view-fill-long-lines))
   #+END_SRC

** =org-mode=

   The following is a temporary hack until straight.el supports building Org,
   see:
  
   - https://github.com/raxod502/straight.el/issues/211
   - https://github.com/raxod502/radian/issues/410
  
   There are three things missing from our version of Org: the functions
   =org-git-version= and =org-release=, and the feature =org-version=. We
   provide all three of those ourself, therefore.

   #+BEGIN_SRC emacs-lisp
     (require 'subr-x)
     (straight-use-package 'git)

     (defun org-git-version ()
       "The Git version of org-mode.
     Inserted by installing org-mode or when a release is made."
       (require 'git)
       (let ((git-repo (expand-file-name
                        "straight/repos/org/" user-emacs-directory)))
         (string-trim
          (git-run "describe"
                   "--match=release\*"
                   "--abbrev=6"
                   "HEAD"))))

     (defun org-release ()
       "The release version of org-mode.
     Inserted by installing org-mode or when a release is made."
       (require 'git)
       (let ((git-repo (expand-file-name
                        "straight/repos/org/" user-emacs-directory)))
         (string-trim
          (string-remove-prefix
           "release_"
           (git-run "describe"
                    "--match=release\*"
                    "--abbrev=0"
                    "HEAD")))))

     (provide 'org-version)
   #+END_SRC

   The following is the *actual* configuration.

   #+BEGIN_SRC emacs-lisp
     (use-package org
       :bind (:map org-mode-map
              ("RET" . org-return-indent)
              ("M-p" . outline-previous-visible-heading)
              ("M-n" . outline-next-visible-heading)
              ("s-t" . org-todo))
       :straight org-plus-contrib
       :mode ("\\.org$" . org-mode)
       :init
       (setq org-special-ctrl-a/e t)
       (setq org-return-follows-link t)

       (setq org-export-dispatch-use-expert-ui t)

       (setq org-latex-create-formula-image-program 'imagemagick)
       (setq org-latex-listings 'minted)
       (setq org-tags-column -80)

       (setq org-enforce-todo-dependencies t)
       (setq org-enforce-todo-checkbox-dependencies  t)

       (setq org-pretty-entities t)
       (setq org-src-fontify-natively t)
       (setq org-list-allow-alphabetical t)

       (setq org-deadline-warning-days 7)

       (setq org-agenda-custom-commands
             '(("s" "Schoolwork"
                ((agenda "" ((org-agenda-ndays 14)
                             (org-agenda-start-on-weekday nil)
                             (org-agenda-prefix-format " %-12:c%?-12t% s")))
                 (tags-todo "CATEGORY=\"Schoolwork\""
                            ((org-agenda-prefix-format "%b")))))

               ("r" "Reading"
                ((tags-todo "CATEGORY=\"Reading\""
                            ((org-agenda-prefix-format "%:T ")))))
               ("m" "Movies"
                ((tags-todo "CATEGORY=\"Movies\""
                            ((org-agenda-prefix-format "%:T ")))))))
         (setq
          org-latex-pdf-process (list "latexmk -shell-escape -pdf %f")

         org-entities-user
         '(("supsetneqq" "\\supsetneqq" t "" "[superset of above not equal to]"
            "[superset of above not equal to]" "⫌")
           ("subseteq" "\\subseteq" t "" "[subset of above equal to]" "subset of above equal to" "⊆")
            ("subsetneqq" "\\subsetneqq" t "" "[suberset of above not equal to]"
              "[suberset of above not equal to]" "⫋")))

       :config
       (setq org-agenda-files '("~/agenda/"))
       (plist-put org-format-latex-options :scale 1.5)

       (setq org-latex-packages-alist
         '(("" "minted") ("usenames,dvipsnames,svgnames" "xcolor")))

       (defun my-org-autodone (n-done n-not-done)
         "Switch entry to DONE when all subentries are done, to TODO otherwise."
         (let (org-log-done org-log-states)   ; turn off logging
           (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

       (add-hook 'org-after-todo-statistics-hook 'my-org-autodone)

       (org-babel-do-load-languages
         'org-babel-load-languages
         '((emacs-lisp . t)
            (latex     . t)
            (python    . t)
            ;; FIXME: Make this contingent on ob-ipython
            ;; (ipython   . t)
            (R         . t)
            (octave    . t)
            (matlab    . t)
            (shell     . t)))

       (setq org-confirm-babel-evaluate nil)
       (setq org-export-use-babel t)

       (setq org-latex-minted-options
         '(("linenos" "true")
            ("fontsize" "\\scriptsize")
            ("frame" "lines")))

       (setq org-export-latex-hyperref-format "\\ref{%s}")

       (setq
         org-src-window-setup 'current-window
         org-agenda-window-setup 'current-window)

       (setq org-blank-before-new-entry
         '((heading . true)
            (plain-list-item . auto)))

       ;; FIXME: parameter-ize dir `agenda'
       (setq org-default-notes-file "~/agenda/notes.org")

       (setq org-capture-templates
             `(("r" "Reading" entry (file "~/proj/lists/read.org")
                "* TODO %?\n  Entered on %U\n  %i")
               ("t" "Task" entry (file "")
                "* TODO %?\n %i")))

       (setq org-refile-targets '((nil . (:maxlevel . 10))))

       (setq org-export-with-smart-quotes t)
       (with-eval-after-load 'ace-link
         ;; (bind-keys :map org-agenda-mode-map
         ;;            ("M-o" . ace-link-org))
         (bind-keys :map org-mode-map
                    ("M-o" . ace-link-org))))

     (use-package ox-latex
       :after org)

     (use-package ox-bibtex
       :after org)

     (use-package ox-md
       :after org)

     (use-package ob-python
       :after org
       :init
       (setq org-babel-python-command "python3"))

     (use-package toc-org
       :disabled t
       :after org
       :config
       (add-hook 'org-mode-hook 'toc-org-enable))

     (use-package evil-org
       :straight t
       :after (evil org)
       :config
       (add-hook 'org-mode-hook 'evil-org-mode)
       (evil-org-set-key-theme)
       (setq evil-org-special-o/O '(table-row)))

     (use-package org-tempo
       :after org)
   #+END_SRC

** Org-page

   #+BEGIN_SRC emacs-lisp
     (use-package org-page
     :after org
     :straight t)
   #+END_SRC

** =pdf-tools=

   #+BEGIN_SRC emacs-lisp
     (use-package pdf-tools
       :straight t
       :mode ("\\.pdf$" . pdf-view-mode)
       :config
       (pdf-tools-install)

       (let ((foreground-orig (car pdf-view-midnight-colors)))
         (setq pdf-view-midnight-colors
               (cons "white" "black")))

       (with-eval-after-load 'evil
           (progn
             (add-to-list 'evil-emacs-state-modes 'pdf-outline-buffer-mode)
             (add-to-list 'evil-emacs-state-modes 'pdf-view-mode))))
   #+END_SRC

** =projectile=

   #+begin_src emacs-lisp
     ;; TODO: For sake of Constant Reader, give some context as to why this might be
     ;; necessary (at least for me)
     (defun jjin/projectile-absolute-compilation-dir-maybe ()
       "Returns the default compilation dir of the current Projectile project type if
       it is an absolute path; otherwise, return nil."
       (let* ((type (projectile-project-type))
              (comp-dir (projectile-default-compilation-dir type)))
         (if (and comp-dir (file-name-absolute-p comp-dir)) comp-dir nil)))
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :straight t
       :diminish projectile-mode
       :init
       (setq projectile-globally-ignored-files '("TAGS"
                                                 "GPATH"
                                                 "GRTAGS"
                                                 "GSYMS"
                                                 "GTAGS")
             projectile-globally-ignored-file-suffixes '("~"))

       ;; We'd like projects contained within other projects, e.g. packages pulled
       ;; into the .emacs.d/.straight dir via straight.el, to be recognized as
       ;; Projectile packages.

       ;; TODO: This doesn't play well with monorepo structures that might have
       ;; multiple "project root" files scattered throughout the codebase.
       ;; (setq projectile-project-root-files-functions
       ;;       '(projectile-root-local
       ;;         projectile-root-top-down
       ;;         projectile-root-top-down-recurring
       ;;         projectile-root-bottom-up))

       :config
       (define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
       (advice-add 'projectile-compilation-dir
                   :before-until
                   'jjin/projectile-absolute-compilation-dir-maybe)

       ;; MacOS file system is case insensitive. This means that, when combined with
       ;; top-down root discovery, .git directory's `description' file conflicts with
       ;; the `DESCRIPTION' element -- intended for R projects -- in the default
       ;; value of `projectile-project-root-file'.
       ;;
       ;; Since I really don't use R and don't plan to anytime soon, removing it from
       ;; here. Can revisit if/when ever necessary.
       (setq projectile-project-root-files
             (remove "DESCRIPTION" projectile-project-root-files))
       (bind-key "<f12>"
                 (lambda ()
                   "Save all project buffers and compile"
                   (interactive)
                   (projectile-save-project-buffers)
                   (let (compilation-read-command)
                     (projectile-compile-project nil)))
                 projectile-mode-map)

       (bind-key "c"
                 (lambda (arg)
                   "Run `helm-make-projectile' if the package is
     installed and the project contains a Makefile. Otherwise,
     fallback to default, i.e. `projectile-compile-project'."
                   (interactive "P")
                   (if (and (package-installed-p 'helm-make)
                            (file-exists-p (concat (projectile-project-root) "Makefile")))
                       (helm-make-projectile (prefix-numeric-value arg))
                     (projectile-compile-project arg)))
                 projectile-command-map)

       (setq projectile-enable-caching t)

       (with-eval-after-load 'helm
           (setq projectile-completion-system 'helm
                 projectile-switch-project-action 'helm-projectile))

       (projectile-global-mode)

       ;; "disables "mode-line setting by project; extreme hang-up over SSH/Tramp
       (setq projectile-mode-line "Projectile")
       (add-to-list 'projectile-globally-ignored-modes "term-mode")

       (use-package ggtags
         :disabled t
         :config
         (with-eval-after-load 'evil
             (add-to-list 'evil-emacs-state-modes 'ggtags-view-search-history-mode))

         (add-hook 'c-mode-hook 'ggtags-mode)
         (add-hook 'c++-mode-hook 'ggtags-mode)
         (add-hook 'java-mode-hook 'ggtags-mode)))
   #+END_SRC

** =rich-minority-mode=

   #+BEGIN_SRC emacs-lisp
     (use-package rich-minority
       :straight t
       :config
       (defconst my-rm-excluded-modes
         '(
            " pair"
            " Fill"
            " end"
            " Ace - Window"))
       (dolist (mode my-rm-excluded-modes)
         (add-to-list 'rm-excluded-modes mode)))
   #+END_SRC

** =smart-mode-line=

   #+BEGIN_SRC emacs-lisp
     (use-package smart-mode-line
       :straight t
       :init
       (setq sml/theme 'respectful)
       :config
       (sml/setup)
       (smart-mode-line-enable))
   #+END_SRC

** =tramp=

   #+BEGIN_SRC emacs-lisp
     (use-package tramp
       :init
       (setq tramp-default-method "ssh")
       (setq password-cache-expiry nil)
       :config

       (add-to-list 'tramp-remote-path "~/bin"))
   #+END_SRC

** =undo-tree=

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :diminish undo-tree-mode
       :bind ("C-<backspace>" . undo-tree-undo))
   #+END_SRC

** =w3m=

   #+BEGIN_SRC emacs-lisp
     (use-package w3m
       :straight t
       :bind (:map w3m-mode-map
              ("P" . w3m-view-previous-page)
              ("n" . w3m-tab-next-buffer)
              ("p" . w3m-tab-previous-buffer)
              ("w" . w3m-delete-buffer))
       :commands w3m
       :init
       (with-eval-after-load 'helm-exec
         (helm-exec-register-executable 'w3m))
       (setq w3m-fill-column 80)

       :config
       (with-eval-after-load 'evil
         (add-to-list 'evil-emacs-state-modes 'w3m-session-select-mode))
       (with-eval-after-load 'ace-link
         (bind-keys :map w3m-mode-map
                    ("o" . ace-link-w3m)))

       (unbind-key "B" w3m-mode-map))

     (use-package w3m-session
       :after w3m)
   #+END_SRC

* (Un)license

  #+BEGIN_SRC text :eval never
    This is free and unencumbered software released into the public domain.

    Anyone is free to copy, modify, publish, use, compile, sell, or
    distribute this software, either in source code form or as a compiled
    binary, for any purpose, commercial or non-commercial, and by any
    means.

    In jurisdictions that recognize copyright laws, the author or authors
    of this software dedicate any and all copyright interest in the
    software to the public domain. We make this dedication for the benefit
    of the public at large and to the detriment of our heirs and
    successors. We intend this dedication to be an overt act of
    relinquishment in perpetuity of all present and future rights to this
    software under copyright law.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
    OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

    For more information, please refer to <http://unlicense.org>
  #+END_SRC

