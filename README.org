# -*- after-save-hook: (org-html-export-to-html org-babel-tangle); -*-

#+TITLE: Jonathan Jin's Emacs Configuration
#+AUTHOR: Jonathan Jin
#+PROPERTY: header-args:emacs-lisp :exports code :results none :tangle init.el

#+HTML_HEAD:    <!-- Global site tag (gtag.js) - Google Analytics -->
#+HTML_HEAD:    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-42551205-2"></script>
#+HTML_HEAD:    <script>
#+HTML_HEAD:    window.dataLayer = window.dataLayer || [];
#+HTML_HEAD:    function gtag(){dataLayer.push(arguments);}
#+HTML_HEAD:    gtag('js', new Date());
#+HTML_HEAD:    gtag('config', 'UA-42551205-2');
#+HTML_HEAD:    </script>

#+EXPORT_FILE_NAME: index

#+SETUPFILE: theme.setup

* Preamble

  #+BEGIN_SRC emacs-lisp
    (add-to-list 'load-path (expand-file-name "~/.emacs.d/elpa"))

    (setq package-archives '(("gnu"           . "http://elpa.gnu.org/packages/")
                              ("melpa-stable" . "http://stable.melpa.org/packages/")
                              ("melpa"        . "http://melpa.org/packages/")
                              ("org"          . "http://orgmode.org/elpa/")))

    (package-initialize)
  #+END_SRC

** Baseline packages

   We use =use-package= for these configs. Check for its existence and install
   if necessary here.

   #+BEGIN_SRC emacs-lisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))

     (eval-when-compile
       (require 'use-package))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package diminish)

     (use-package names
       :ensure t)
   #+END_SRC

** Functions

   #+BEGIN_SRC emacs-lisp
     (define-namespace jjin-
     (defun load-if-exists (file)
       "Loads file, conditional on its existence; no effect if non-existent."
       (when (file-exists-p file)
         (load-file file)))

     (defun kill-current-buffer ()
       (interactive)
       (kill-buffer (current-buffer)))

     (defun window-toggle-split-direction ()
       "Switch window split from horizontally to vertically, or vice versa.

     i.e. change right window to bottom, or change bottom window to right."
       (interactive)
       (require 'windmove)
       (let ((done))
         (dolist (dirs '((right . down) (down . right)))
           (unless done
             (let* ((win (selected-window))
                    (nextdir (car dirs))
                    (neighbour-dir (cdr dirs))
                    (next-win (windmove-find-other-window nextdir win))
                    (neighbour1 (windmove-find-other-window neighbour-dir win))
                    (neighbour2 (if next-win (with-selected-window next-win
                                               (windmove-find-other-window
                                                neighbour-dir next-win)))))

               (setq done (and (eq neighbour1 neighbour2)
                               (not (eq (minibuffer-window) next-win))))
               (if done
                   (let* ((other-buf (window-buffer next-win)))
                     (delete-window next-win)
                     (if (eq nextdir 'right)
                         (split-window-vertically)
                       (split-window-horizontally))
                     (set-window-buffer (windmove-find-other-window neighbour-dir)
                                        other-buf))))))))

     (defun insert-newline-after ()
       (interactive)
       (let ((oldpos (point)))
         (end-of-line)
         (newline-and-indent)
         (goto-char oldpos)))

     (defun set-opacity (value)
       "Sets the opacity of the frame window. 0=transparent/100=opaque"
       (interactive "nOpacity Value (0 - 100 opaque): ")
       (set-frame-parameter (selected-frame) 'alpha value))

     (defun dired-at-current ()
       (interactive)
       (dired default-directory))

     (defun prev-window ()
       (interactive)
       (other-window -1))

     ;; credit: https://gist.github.com/mads379/3402786
     ;; TODO: modeline indication
     ;; TODO: if maximized, prevent other window splitting (use minor mode?)
     (defun toggle-maximize-window ()
       "Maximize window"
       (interactive)
       (if (= 1 (length (window-list)))
           (jump-to-register '_)
         (progn
           (window-configuration-to-register '_)
           (delete-other-windows))))

     ;; credit: https://github.com/abo-abo/hydra/blob/master/hydra-examples.el
     (defun move-splitter-left (arg)
       "Move window splitter left."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'right))
           (shrink-window-horizontally arg)
         (enlarge-window-horizontally arg)))

     ;; credit: https://github.com/abo-abo/hydra/blob/master/hydra-examples.el
     (defun move-splitter-right (arg)
       "Move window splitter right."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'right))
           (enlarge-window-horizontally arg)
         (shrink-window-horizontally arg)))

     ;; credit: https://github.com/abo-abo/hydra/blob/master/hydra-examples.el
     (defun move-splitter-up (arg)
       "Move window splitter up."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'up))
           (enlarge-window arg)
         (shrink-window arg)))

     ;; credit: https://github.com/abo-abo/hydra/blob/master/hydra-examples.el
     (defun move-splitter-down (arg)
       "Move window splitter down."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'up))
           (shrink-window arg)
         (enlarge-window arg)))

     ;; TODO: set modeline
     (defun toggle-dedicated ()
       (interactive)
       (set-window-dedicated-p (selected-window)
                               (not (window-dedicated-p (selected-window)))))

     (defun bury-compile-buffer-if-successful (buffer string)
       "Bury a compilation buffer if succeeded without warnings "
       (if (and
            (string-match "compilation" (buffer-name buffer))
            (string-match "finished" string)
            (not
             (with-current-buffer buffer
               (search-forward "warning" nil t))))
           (run-with-timer 1 nil
                           (lambda (buf)
                             (bury-buffer buf)
                             (delete-window (get-buffer-window buf)))
                           buffer)))
     (defun get-current-displays ()
       "Get alist of attributes of displays w/ Emacs buffers."
       (require 'cl)
       (interactive)
       (remove-if
        (lambda (disp)
          (eq nil (cdr (assoc 'frames disp))))
        (display-monitor-attributes-list)))

     (defun fontify-frame ()
       (interactive)
       "Adjusts frame's text size according to current display's
     resolution. Prevents illegibly small text on high-resolution
     displays and, similarly, impractically large text on
     low-resolution displays."
       ;; FIXME: assumes only one emacs frame on one disp
       (let* ((curr-disp (car (jjin-get-current-displays)))
              (disp-width (nth 3 (assoc 'geometry curr-disp)))
              (font-name (if (eq system-type 'darwin) "Terminus (TTF)" "Terminus"))
              (font-size (if (> disp-width 2000) "12" "04")))
         (if (display-graphic-p)
             (set-frame-parameter nil 'font (string-join `(,font-name ,font-size) " "))))))
   #+END_SRC

* General Configurations

  #+BEGIN_SRC emacs-lisp
    (jjin-load-if-exists "~/.secrets.el")

    (setq ring-bell-function 'ignore)

    (setq large-file-warning-threshold nil)

    (setq
      user-mail-address "jjin082693@gmail.com"
      user-full-name  "Jonathan Jin")

    (setq
      inhibit-startup-screen t
      inhibit-startup-message t
      initial-scratch-message nil
      visible-bell t
      use-dialog-box nil)

    (setq-default
      fill-column 80
      indent-tabs-mode nil
      tab-width 4)

    (setq next-line-add-newlines t)

    (setq scroll-step 1
      scroll-conservatively 10000
      scroll-margin 3)

    (fset 'yes-or-no-p 'y-or-n-p)

    (if window-system
        (progn
          (tool-bar-mode     0)
          (scroll-bar-mode   0)
          (menu-bar-mode     0)
          (line-number-mode  0)))

    (blink-cursor-mode 0)

    (global-auto-revert-mode)
    (setq auto-revert-remote-files t)

    (global-hl-line-mode 1)
    (column-number-mode  1)
    (show-paren-mode     1)

    (electric-pair-mode)

    (delete-selection-mode +1)

    (add-hook 'prog-mode-hook 'turn-on-auto-fill)
    (add-hook 'text-mode-hook 'turn-on-auto-fill)

    (fringe-mode '(4 . 0))

    (with-eval-after-load 'dired
      (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file))

    (put 'dired-find-alternate-file 'disabled nil)

    (setq echo-keystrokes 0)

    (setq image-dired-external-viewer "feh")

    (setq term-ansi-default-program (getenv "SHELL"))

    (setq enable-remote-dir-locals t)

    (defconst custom-file-path "~/.emacs-custom.el")
    (if (file-exists-p custom-file-path)
        (load (setq custom-file custom-file-path)))
  #+END_SRC

** Scratch Org-mode

   I spend more time in Org-mode than I do writing Elisp.

   #+BEGIN_SRC emacs-lisp
     (setq initial-major-mode 'org-mode)
   #+END_SRC

** Appearance

*** Themes

    #+BEGIN_SRC emacs-lisp

      (use-package gotham-theme
        :if window-system
        :disabled t
        :config
        (load-theme 'gotham t)) 

      (use-package nord-theme
        :if window-system
        :ensure t
        :config
        (load-theme 'nord t))
    #+END_SRC

*** General

    #+BEGIN_SRC emacs-lisp
      (setq-default x-stretch-cursor t)

      (setq custom-safe-themes t)

      (set-frame-font
       (cond 
        ((string= "gnu/linux" system-type) "-xos4-terminus-medium-r-normal--28-*-72-72-c-140-iso10646-1")
        ((string= "darwin" system-type) "Terminus (TTF) 12")
         (t "Terminus 12")))

      (when (functionp 'set-fontset-font)
        (set-fontset-font "fontset-default"
                          'unicode
                          (font-spec :family "DejaVu Sans Mono")))

      (jjin-set-opacity 90)
    #+END_SRC

** Environment-specific

*** Mac

    #+BEGIN_SRC emacs-lisp
      (when (eq system-type 'darwin)
        (setq mac-command-modifier 'meta)
        (setq system-uses-terminfo nil)
        (toggle-frame-fullscreen))
    #+END_SRC

** Server

   Make sure =EDITOR= and/or =VISUAL= is/are set to =emacsclient=.

   #+BEGIN_SRC emacs-lisp
     (use-package server
       :config
       (unless (server-running-p) (server-start)))
   #+END_SRC

** Final

   We set these parameters after visual environment has finished configuration,
   since some settings, e.g. that for =split-width-threshold=, are dependent.

   #+BEGIN_SRC emacs-lisp
     (setq split-width-threshold (* 0.8 (frame-width)))
   #+END_SRC
   
* Keys

** Personal maps

   #+BEGIN_SRC emacs-lisp
     (define-prefix-command 'jjin-vc-map)
     (bind-key "C-c v" 'jjin-vc-map)

     (define-prefix-command 'jjin-chat-map)
     (bind-key "C-c i" 'jjin-chat-map)

     (define-prefix-command 'jjin-comment-map)
     (bind-key "C-c c" 'jjin-comment-map)

     (define-prefix-command 'jjin-exec-map)
     (bind-key "C-c e" 'jjin-exec-map)

     (define-prefix-command 'jjin-term-map)
     (bind-key "C-c t" 'jjin-term-map)

     (define-prefix-command 'jjin-buffer-map)
     (bind-key "C-c b" 'jjin-buffer-map)

     (define-prefix-command 'jjin-mail-map)
     (bind-key "C-c m" 'jjin-mail-map)
   #+END_SRC

** Keybindings

   #+BEGIN_SRC emacs-lisp
     (bind-keys :map global-map
                ("C-x k"              . jjin-kill-current-buffer)
                ("RET"                . newline-and-indent))

     (unbind-key "<menu>")
     (unbind-key "M-`")
     (unbind-key "C-c C-w")
     (unbind-key "C-x C-n")      ; set-goal-column

     (unbind-key "<f10>")
     (unbind-key "<f11>")
     (unbind-key "M-<f10>")
     (unbind-key "<escape> <f10>")

     (bind-keys :map jjin-buffer-map
                ("r" . rename-buffer))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package hydra
       :after ace-window
       :ensure t
       :config
       (defhydra jjin-hydra-window (global-map "C-c w")
         "Commands relating to window manipulation"
         ("h" windmove-left "move left")
         ("l" windmove-right "move right")
         ("j" windmove-down "move down")
         ("k" windmove-up "move up")
         ("q" delete-window "delete window")
         ("Q" kill-buffer-and-window "kill buffer, delete window")
         ("H" jjin-move-splitter-left "move splitter left")
         ("L" jjin-move-splitter-right "move splitter right")
         ("J" jjin-move-splitter-down "move splitter down")
         ("K" jjin-move-splitter-up "move splitter up")
         ("b" balance-windows)
         ("|" jjin-window-toggle-split-direction)
         ("s" split-window-below "split window (below)")
         ("v" split-window-right "split window (right)")
         (";" ace-window "select window" :exit t)))
   #+END_SRC

* Development Environments

** General Style

   #+BEGIN_SRC emacs-lisp
     (c-set-offset 'arglist-intro '+)
     (c-set-offset 'arglist-close 0)
   #+END_SRC

** C/C++

   #+BEGIN_SRC emacs-lisp
     (setq c-block-comment-prefix "* ")

     (defvaralias 'c-basic-offset 'tab-width)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package irony
       :disabled t
       :commands irony-mode
       :init
       (add-hook 'c-mode-hook 'irony-mode)
       (add-hook 'c++-mode-hook 'irony-mode)
       :config
       (use-package flycheck-irony
         :config
         (add-hook 'flycheck-mode-hook 'flycheck-irony-setup)))

     (use-package company-irony
       :disabled t
       :config
       (add-to-list 'company-backends 'company-irony))

     (use-package clang-format
       :disabled t
       :config
       (add-to-list 'auto-mode-alist '("\\.clang-format$" . yaml-mode)))
   #+END_SRC

** Go

   #+BEGIN_SRC emacs-lisp
     (use-package go-mode
       :mode "\\.go$"
       :ensure t

       :init
       (if (executable-find "goimports")
           (setq gofmt-command "goimports")
         (message "Goimports not found; using default `gofmt-command'"))

       :config
       (add-hook 'before-save-hook 'gofmt-before-save)

       (use-package company-go :disabled t)
       (use-package go-guru))
   #+END_SRC

** Lisp

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("emacs$" . emacs-lisp-mode))
     (add-to-list 'auto-mode-alist '("Cask" . emacs-lisp-mode))
   #+END_SRC

** Javascript

   #+BEGIN_SRC emacs-lisp
     (defvaralias 'js-indent-level 'tab-width)

     (use-package js2-mode
       :mode (("\\.js$" . js2-mode)
              ("\\.jsx$" . js2-jsx-mode))
       :ensure t)

   #+END_SRC

** Java

** LaTeX

   #+BEGIN_SRC emacs-lisp
     ;; sets latex-mode to compile w/ pdflatex by default
     (setq TeX-PDF-mode t
         TeX-parse-self t
         TeX-newline-function 'reindent-then-newline-and-indent)

     (eval-after-load "tex"
         '(setcdr (assoc "LaTeX" TeX-command-list)
              '("%`%l%(mode) -shell-escape%' %t"
                   TeX-run-TeX nil (latex-mode doctex-mode) :help "Run LaTeX")))

     ;; latex-mode-specific hooks (because latex-mode is not derived from prog-mode)
     (add-hook 'LaTeX-mode-hook
         (lambda ()
             (TeX-fold-mode 1)
             (auto-fill-mode)
             (add-to-list 'TeX-command-list '("XeLaTeX" "%`xelatex%(mode)%' %t"
                                                 TeX-run-TeX nil t))))
   #+END_SRC

** zsh

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("zshrc$" . sh-mode))
     (add-to-list 'auto-mode-alist '("\\.zsh$" . sh-mode))
   #+END_SRC

** Haskell

   #+BEGIN_SRC emacs-lisp
     (use-package haskell-mode
       :disabled t
       :config
       (add-hook 'haskell-mode-hook 'turn-on-haskell-indent))
   #+END_SRC

** Ruby

   #+BEGIN_SRC emacs-lisp
     (use-package enh-ruby-mode
       :disabled t
       :mode ("Gemfile" "Guardfile")
       :config
       (defvaralias 'ruby-indent-level 'tab-width))

     (use-package ruby-end
       :disabled t
       :config
       (add-hook 'ruby-mode-hook 'ruby-end-mode))
   #+END_SRC

** SQL

   #+BEGIN_SRC emacs-lisp
     (setq sql-mysql-options '("--local-infile"))

     (add-hook 'sql-interactive-mode-hook
               (lambda ()
                 (toggle-truncate-lines t)))
   #+END_SRC

** Thrift

   #+BEGIN_SRC emacs-lisp
     (use-package thrift

       :config
       (add-hook 'thrift-mode-hook
                 (lambda ()
                   (setq comment-start "//")
                   (setq comment-end ""))))
   #+END_SRC

** Octave

   #+BEGIN_SRC emacs-lisp
     (use-package octave
       :mode ("\\.m$" . octave-mode)
       :interpreter ("octave" . octave-mode)
       :config
       (with-eval-after-load 'evil
           (progn
             (add-to-list 'evil-emacs-state-modes 'octave-help-mode)
             (add-to-list 'evil-emacs-state-modes 'inferior-octave-mode)))

       (setq inferior-octave-program "octave-cli")
       (setq inferior-octave-prompt ">> ")
       (setq inferior-octave-dynamic-complete-functions '(comint-filename-completion))

       (setq inferior-octave-startup-args '("-i" "--line-editing" "-q" "--traditional")))
   #+END_SRC

** Matlab

   #+BEGIN_SRC emacs-lisp
     (use-package matlab
       :init
       (setq matlab-shell-command-switches '("-nodesktop")))
   #+END_SRC

** Python

   #+BEGIN_SRC emacs-lisp
     (use-package pyvenv)

     (use-package ob-ipython)

     (use-package elpy
       :ensure t
       :init
       (setq elpy-modules '(elpy-module-company
                            elpy-module-eldoc
                            elpy-module-flymake
                            elpy-module-pyvenv
                            elpy-module-yasnippet
                            elpy-module-sane-defaults))
       (elpy-enable))
  
   #+END_SRC

** Emacs Lisp

   #+BEGIN_SRC emacs-lisp
     (use-package elisp-mode
       :bind (("C-c C-f" . find-function)))
   #+END_SRC
* General Packages

** =ace-link=

   #+BEGIN_SRC emacs-lisp
     (use-package ace-link
       :commands (ace-link-eww ace-link-setup-default)
       :init (ace-link-setup-default))
   #+END_SRC

** =ace-window=

   #+BEGIN_SRC emacs-lisp
     (use-package ace-window
       :ensure t
       :init
       (setq aw-keys '(?a ?r ?s ?t ?q ?w ?f ?p))

       :config
       ;; technically should be able to use mu4e~update-name but for whatever reason
       ;; the mu4e update index function uses the hardcoded string w/ space padding.
       (add-to-list 'aw-ignored-buffers " *mu4e-update*"))
   #+END_SRC

** =ansi-color=

   #+BEGIN_SRC emacs-lisp
     (use-package ansi-color
       :init
       (setq ansi-color-faces-vector
         [default bold shadow italic underline bold bold-italic bold])
       (setq compilation-scroll-output t)
       :config
       (defun colorize-compilation-buffer ()
         (toggle-read-only)
         (ansi-color-apply-on-region (point-min) (point-max))
         (toggle-read-only))

       (add-hook 'compilation-filter-hook 'colorize-compilation-buffer))
   #+END_SRC

** =browse-url=

   #+BEGIN_SRC emacs-lisp
     (use-package browse-url
       :config
       (setq browse-url-browser-function
             (if (browse-url-can-use-xdg-open) 'browse-url-xdg-open
               'browse-url-default-browser))

       ;; FIXME: regex search for chromium (some distros package the name differently)
       (setq browse-url-generic-program
             (if (eq system-type 'darwin)
                 "open"
               (executable-find "chromium-browser")))

       (setq shr-external-browser 'browse-url-generic))
   #+END_SRC

** =calc=

   #+BEGIN_SRC emacs-lisp
     (use-package calc
       :init
       (bind-key "c" 'calc jjin-exec-map))
   #+END_SRC

** =conf-mode=

   #+BEGIN_SRC emacs-lisp
     (use-package conf-mode
       :mode
       (;; systemd
         ("\\.service\\'"     . conf-unix-mode)
         ("\\.timer\\'"      . conf-unix-mode)
         ("\\.target\\'"     . conf-unix-mode)
         ("\\.mount\\'"      . conf-unix-mode)
         ("\\.automount\\'"  . conf-unix-mode)
         ("\\.slice\\'"      . conf-unix-mode)
         ("\\.socket\\'"     . conf-unix-mode)
         ("\\.path\\'"       . conf-unix-mode)

         ;; general
         ("conf\\(ig\\)?$"   . conf-mode)
         ("rc$"              . conf-mode)))

   #+END_SRC

** =company=

   #+BEGIN_SRC emacs-lisp
     (use-package company
       :defines company-backends
       :diminish company-mode
       :ensure t
       :config
       (add-hook 'after-init-hook 'global-company-mode)
       (setq company-idle-delay 0.1))
   #+END_SRC

** =dired=

   #+BEGIN_SRC emacs-lisp
     (setq dired-listing-switches "-alh")

     (use-package dired-open
       :init
       (setq dired-open-extensions '(("mp4" . "vlc")
                                     ("avi" . "vlc"))))
   #+END_SRC

** =doc-view-mode=

   #+BEGIN_SRC emacs-lisp
     (use-package doc-view
       :init
       (setq doc-view-resolution 200))
   #+END_SRC

** =debbugs=

   #+BEGIN_SRC emacs-lisp
     (use-package debbugs
       :ensure t
       :config
       (with-eval-after-load 'evil
           (add-to-list 'evil-emacs-state-modes 'debbugs-gnu-mode)))
   #+END_SRC

** =ediff=

   #+BEGIN_SRC emacs-lisp
     (use-package ediff
       :init
       (setq ediff-window-setup-function 'ediff-setup-windows-plain))
   #+END_SRC

** Eshell

   #+BEGIN_SRC emacs-lisp
     (use-package eshell
       :init
       (setq eshell-rc-script (concat user-emacs-directory "eshell/profile"))
       :config
       (with-eval-after-load 'evil
         (progn
           (delete 'eshell-mode evil-insert-state-modes)
           (add-to-list 'evil-emacs-state-modes 'eshell-mode)))
       (bind-keys :map jjin-term-map
                  ("e" . eshell)))
   #+END_SRC
   
*** Initialization file

    #+BEGIN_SRC emacs-lisp :tangle eshell/profile
    (setenv "EDITOR" "emacsclient")
    #+END_SRC

** =ess=

   #+BEGIN_SRC emacs-lisp
     (use-package ess-site
       :disabled t
       :ensure ess
       :commands (inferior-ess-mode ess-help-mode)
       :init
       (setq inferior-R-args "--quiet")

       :config
       (with-eval-after-load 'evil
           (progn
             (add-to-list 'evil-emacs-state-modes 'inferior-ess-mode)
             (add-to-list 'evil-emacs-state-modes 'ess-help-mode)))
       (bind-key "C-c C-w" nil inferior-ess-mode-map))
   #+END_SRC

** Evil (base + extras)

   #+BEGIN_SRC emacs-lisp
     (use-package evil
       :ensure t
       :pin melpa
       :defines evil-normal-state-map
       :init
       (setq evil-esc-delay 0)

       :config
       (mapc (lambda (m) (add-to-list 'evil-emacs-state-modes m t))
         '(eshell-mode
            calendar-mode

            finder-mode
            info-mode

            eww-mode
            eww-bookmark-mode

            dired-mode
            image-mode
            image-dired-thumbnail-mode
            image-dired-display-image-mode

            git-rebase-mode

            help-mode

            sql-interactive-mode
            org-capture-mode))
       ;; FIXME: what's the diff between set-initial-state and adding to list directly?
       (evil-set-initial-state 'term-mode 'emacs)

       (bind-keys :map evil-emacs-state-map
         ("<escape>" . evil-execute-in-normal-state))

       (bind-keys :map evil-insert-state-map
                  ("<return>" . newline-and-indent))

       (evil-mode 1))

     (use-package evil-numbers
       :after evil
       :ensure t
       :config
       (bind-keys :map evil-normal-state-map
                  ("C-a"   . evil-numbers/inc-at-pt)
                  ("C-c -" . evil-numbers/dec-at-pt)))

     (use-package evil-search-highlight-persist
       :after evil
       :ensure t
       :config
       (bind-key "C-l" 'evil-search-highlight-persist-remove-all
                 evil-normal-state-map)
       (global-evil-search-highlight-persist t)

       (set-face-attribute
        'evil-search-highlight-persist-highlight-face
        nil
        :background (face-attribute 'match :background)))


     (use-package evil-surround
       :after evil
       :ensure t
       :pin melpa-stable
       :config
       (global-evil-surround-mode 1))

     (use-package evil-nerd-commenter
       :after evil
       :ensure t
       :config
       (bind-keys :map jjin-comment-map
                  ("i" . evilnc-comment-or-uncomment-lines)
                  ("l" . evilnc-quick-comment-or-uncomment-to-the-line)
                  ("c" . evilnc-copy-and-comment-lines)
                  ("p" . evilnc-comment-or-uncomment-paragraphs)
                  ("v" . evilnc-toggle-invert-comment-line-by-line)))

   #+END_SRC

** =fill-column-indicator=

   #+BEGIN_SRC emacs-lisp
     (use-package fill-column-indicator
       :commands turn-on-fci-mode
       :ensure t
       :init
       ;; (add-hook 'prog-mode-hook 'turn-on-fci-mode)
       ;; (add-hook 'text-mode-hook 'turn-on-fci-mode)
       (setq fci-rule-color (face-attribute 'highlight :background)))
   #+END_SRC

** =flycheck=

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :disabled t
       :defines flycheck-mode-hook
       :config
       (add-hook 'after-init-hook #'global-flycheck-mode))
   #+END_SRC

** Git

   #+BEGIN_SRC emacs-lisp
     (bind-keys :map jjin-vc-map
                ("g" . vc-git-grep))
   #+END_SRC

*** =git-commit-mode=

    #+BEGIN_SRC emacs-lisp
      (use-package git-commit-mode
        :commands git-commit-mode)
    #+END_SRC

*** =gitconfig-mode=
    #+BEGIN_SRC emacs-lisp
      (use-package gitconfig-mode
        :ensure t
        :mode "gitconfig")
    #+END_SRC

*** =gitignore-mode=

    #+BEGIN_SRC emacs-lisp
      (use-package gitignore-mode
        :ensure t
        :mode "gitignore")
    #+END_SRC

*** =magit=

    #+BEGIN_SRC emacs-lisp
      (use-package magit
        :ensure t
        :init
        (setq magit-popup-show-common-commands nil)
        (setq magit-log-arguments '("--graph"
                                    "--decorate"
                                    "--color"))

        :config
        (bind-keys :map jjin-vc-map
                   ("v" . magit-status)
                   ("l" . magit-log-popup)
                   ("b" . magit-blame-popup)
                   ("f" . magit-fetch-popup)
                   ("F" . magit-pull-popup)
                   ("P" . magit-push-popup)
                   ("z" . magit-stash-popup)
                   ("c" . magit-checkout)
                   ("C" . magit-branch-and-checkout))
        (bind-keys :map magit-mode-map
                   ("X" . magit-reset-hard))
        ;; removes 1.4.0 warning in arguably cleaner way
        (remove-hook 'after-init-hook 'magit-maybe-show-setup-instructions)

        (defadvice magit-blame-mode (after switch-to-emacs-state activate)
          (if magit-blame-mode
              (evil-emacs-state 1)
            (evil-normal-state 1)))

        (with-eval-after-load 'evil
            (add-to-list 'evil-emacs-state-modes 'magit-popup-mode)))
    #+END_SRC

** =helm=

   #+BEGIN_SRC emacs-lisp
     (use-package helm
       :ensure t
       :diminish helm-mode
       :bind (("C-x m"    . helm-M-x)
               ("C-x C-f" . helm-find-files)
               ("C-x b"   . helm-buffers-list))
       :init
       (setq helm-external-programs-associations `(("pdf" . ,(if (eq system-type 'darwin) "open" "zathura"))))
       (setq helm-split-window-inside-p t)

       :config
       (helm-mode 1)
       (helm-autoresize-mode t)

       (defvar helm-source-file-not-found
         (helm-build-dummy-source
             "Create file"
           :action
           (lambda (c) (find-file c))))

       (bind-keys :map jjin-vc-map
                  ("g" . helm-grep-do-git-grep)))

     (use-package helm-make
       :ensure t
       :commands helm-make-projectile
       :init
       (setq helm-make-cache-targets t)
       (setq helm-make-list-target-method 'qp))

     (use-package helm-projectile
       :after projectile
       :bind (:map projectile-command-map
                  ("p"   . helm-projectile)
                  ("a"   . helm-projectile-find-other-file)
                  ("f"   . helm-projectile-find-file)
                  ("F"   . helm-projectile-find-file-in-known-projects)
                  ("s s" . helm-projectile-ag)
                  ("s g" . helm-projectile-grep))
       :ensure t
       :config
       (add-to-list 'helm-projectile-sources-list helm-source-file-not-found t))
   #+END_SRC

** =linum=

   #+BEGIN_SRC emacs-lisp
     (use-package linum
       :ensure t
       :config
       (setq linum-format 'dynamic)
       (global-linum-mode 1)

       (defconst linum-mode-whitelist
         '(prog-mode))

       (require 'mode-local)

       (defadvice linum-mode (around linum-mode-selective activate)
         "Avoids enabling of linum-mode in the buffer having major mode set to one
     of listed in `linum-mode-excludes'."
         (if (or (member major-mode linum-mode-whitelist)
                 (member (get-mode-local-parent major-mode) linum-mode-whitelist))
           ad-do-it)))
   #+END_SRC

** =multi-term=

   #+BEGIN_SRC emacs-lisp
     (use-package multi-term
       :ensure t
       :config
       (bind-keys :map jjin-term-map
                  ("t" . multi-term)
                  ("n" . multi-term-next)
                  ("p" . multi-term-prev)
                  ("d" . multi-term-dedicated-toggle))

       (setq term-bind-key-alist
             '(("C-c C-k" . term-line-mode)
               ("M-]" . multi-term-next)
               ("M-[" . multi-term-prev)
               ("C-c C-c" . term-interrupt-subjob)
               ("C-c C-e" . term-send-esc)
               ("C-m" . term-send-return)
               ("C-y" . term-paste)
               ("M-f" . term-send-forward-word)
               ("M-b" . term-send-backward-word)
               ("M-o" . term-send-backspace)
               ("M-p" . term-send-up)
               ("M-n" . term-send-down)
               ("M-M" . term-send-forward-kill-word)
               ("M-N" . term-send-backward-kill-word)
               ("<M-backspace>" . term-send-backward-kill-word)
               ("M-r" . term-send-reverse-search-history)
               ("M-," . term-send-raw)
               ("M-." . comint-dynamic-complete))))
   #+END_SRC

** =mu4e=

   #+BEGIN_SRC emacs-lisp
     (use-package mu4e
       :load-path (lambda ()
                    (if (eq system-type 'darwin)
                        "/usr/local/Cellar/mu/0.9.16/share/emacs/site-lisp/mu/mu4e"))
       :commands (mu4e mu4e-update-mail-and-index)
       :init
       (bind-keys :map jjin-exec-map ("m" . mu4e))
       (bind-keys :map jjin-mail-map ("m" . mu4e-update-mail-and-index))
       (setq mu4e-context-policy 'pick-first)

       (setq mu4e-headers-include-related nil)

       :config
       (when (eq system-type 'darwin)
         (setq mu4e-mu-binary "/usr/local/bin/mu"))

       ;; make sure the gnutls command line utils are installed
       ;; (require 'smtpmail)

       (setq
        message-send-mail-function 'smtpmail-send-it
        smtpmail-stream-type 'starttls
        smtpmail-default-smtp-server "smtp.gmail.com"
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587)

       (setq
        mu4e-maildir "~/mail"

        mu4e-drafts-folder "/personal/drafts"
        mu4e-sent-folder   "/personal/sent")

       ;; don't save message to Sent Messages, Gmail/IMAP takes care of this
       ;; (See the documentation for `mu4e-sent-messages-behavior' if you have
       ;; additional non-Gmail addresses and want assign them different
       ;; behavior.)
       (setq mu4e-sent-messages-behavior 'delete)

       (setq mu4e-maildir-shortcuts
             '(("/personal/INBOX"   . ?I)
               ("/personal/sent"    . ?S)
               ("/personal/drafts"  . ?D)
               ("/personal/archive" . ?A)
               ("/work/INBOX"   . ?i)
               ("/work/sent"    . ?s)
               ("/work/drafts"  . ?d)
               ("/work/archive" . ?a)))

       (setq mu4e-get-mail-command "offlineimap")

       ;; don't keep message buffers around
       (setq message-kill-buffer-on-exit t)

       (setq
        ;; FIXME: if w3m not installed:
        ;; - log it
        ;; - leave as default
        mu4e-html-renderer 'w3m
        mu4e-html2text-command "w3m -dump -T text/html")

       (add-hook 'mu4e-view-mode-hook 'visual-line-mode)

       (use-package gnus-dired
         :config
         ;; make the `gnus-dired-mail-buffers' function also work on message-mode derived
         ;; modes, such as mu4e-compose-mode
         (defun gnus-dired-mail-buffers ()
           (let (buffers)
             (save-current-buffer
               (dolist (buffer (buffer-list t))
                 (set-buffer buffer)
                 (when (and (derived-mode-p 'message-mode)
                            (null message-sent-message-via))
                   (push (buffer-name buffer) buffers))))
             (nreverse buffers)))

         (setq gnus-dired-mail-mode 'mu4e-user-agent)
         (add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode))

       (set-face-attribute 'mu4e-header-highlight-face nil :underline nil)

       (setq mu4e-compose-signature-auto-include t)

       (setq mail-user-agent 'mu4e-user-agent)

       (add-to-list 'mu4e-view-actions
                    '("View in browser" . mu4e-action-view-in-browser)
                    t)
       (add-to-list 'mu4e-view-actions
                    '("Capture message" . mu4e-action-capture-message)
                    t)

       (setq mu4e-update-interval nil)
       (setq mu4e-headers-skip-duplicates t)
       (setq mu4e-view-show-images t)

       (defun mu4e-message-maildir-matches (msg rx)
         (when rx
           (if (listp rx)
               ;; if rx is a list, try each one for a match
               (or (mu4e-message-maildir-matches msg (car rx))
                   (mu4e-message-maildir-matches msg (cdr rx)))
             ;; not a list, check rx
             (string-match rx (mu4e-message-field msg :maildir)))))

       (setq mu4e-contexts
             `(,(make-mu4e-context
                 :name "personal"
                 :match-func
                 (lambda (msg)
                   (when msg
                     (or
                      (mu4e-message-maildir-matches msg "^/personal")
                      (mu4e-message-contact-field-matches msg :to "jjin082693@gmail.com"))))
                 :vars `((user-mail-address . "jjin082693@gmail.com")
                         (mu4e-compose-signature
                          . ,(concat "Jonathan Jin\n"
                                     "Software Engineer, Uber Technologies\n"
                                     "jjin.info"))
                         (smtpmail-smtp-user . "jjin082693@gmail.com")
                         (user-full-name . "Jonathan Jin")
                         (mu4e-trash-folder . "/personal/trash")
                         (mu4e-drafts-folder . "/personal/drafts")
                         (mu4e-refile-folder . "/personal/archive")))
               ,(make-mu4e-context
                 :name "work"
                 :match-func
                 (lambda (msg)
                   (when msg
                     (or
                      (mu4e-message-maildir-matches msg "^/work")
                      (mu4e-message-contact-field-matches msg :to '("jonathan.jin@uber.com" "@uber.com$")))))
                 :vars `((user-mail-address . "jonathan.jin@uber.com")
                         (mu4e-compose-signature . ,(concat "Jonathan Jin\n"
                                                            "Software Engineer, Observability Applications\n"
                                                            "t.uber.com/jonathan.jin/filememos"))
                         (smtpmail-smtp-user . "jonathan.jin@uber.com")
                         (user-full-name . "Jonathan Jin")
                         (mu4e-trash-folder . "/work/trash")
                         (mu4e-drafts-folder . "/work/drafts")
                         (mu4e-refile-folder . "/work/archive")))))

       (setq mu4e-compose-context-policy 'ask)

       ;; Sets `mu4e-user-mail-address-list' to the concatenation of all
       ;; `user-mail-address' values for all contexts. If you have other mail
       ;; addresses as well, you'll need to add those manually.
       (setq mu4e-user-mail-address-list
             (delq nil
                   (mapcar (lambda (context)
                             (when (mu4e-context-vars context)
                               (cdr (assq 'user-mail-address (mu4e-context-vars context)))))
                           mu4e-contexts)))

       (setq mu4e-view-show-addresses t))
   #+END_SRC

** =org-mode=
   
   #+BEGIN_SRC emacs-lisp
     (use-package org
       :ensure org-plus-contrib
       :pin org
       :mode ("\\.org$" . org-mode)
       :commands (org-capture)
       :init
       (setq org-agenda-files '("~/agenda")
         org-return-follows-link t

         org-export-dispatch-use-expert-ui t

         org-latex-create-formula-image-program 'imagemagick
         org-latex-listings 'minted
         org-tags-column -80

         org-enforce-todo-dependencies t
         org-enforce-todo-checkbox-dependencies  t

         org-pretty-entities t
         org-src-fontify-natively t
         org-list-allow-alphabetical t

         org-todo-keywords
         '((sequence "TODO(t)" "IN-PROGRESS(r)" "|"  "DONE(d)"))

         org-todo-keyword-faces
         '(("TODO" . org-todo) ("IN-PROGRESS" . "yellow") ("DONE" . org-done))

         org-agenda-custom-commands
         '(("s" "Schoolwork"
             ((agenda "" ((org-agenda-ndays 14)
                           (org-agenda-start-on-weekday nil)
                           (org-agenda-prefix-format " %-12:c%?-12t% s")))
               (tags-todo "CATEGORY=\"Schoolwork\""
                 ((org-agenda-prefix-format "%b")))))

            ("r" "Reading"
              ((tags-todo "CATEGORY=\"Reading\""
                 ((org-agenda-prefix-format "%:T ")))))
            ("m" "Movies"
              ((tags-todo "CATEGORY=\"Movies\""
                 ((org-agenda-prefix-format "%:T "))))))

         org-latex-pdf-process (list "latexmk -shell-escape -pdf %f")

         org-entities-user
         '(("supsetneqq" "\\supsetneqq" t "" "[superset of above not equal to]"
            "[superset of above not equal to]" "⫌")
           ("subseteq" "\\subseteq" t "" "[subset of above equal to]" "subset of above equal to" "⊆")
            ("subsetneqq" "\\subsetneqq" t "" "[suberset of above not equal to]"
              "[suberset of above not equal to]" "⫋")))
       :config
       (use-package ob-python
         :init
         (setq org-babel-python-command "python3"))
       (use-package ox-latex)
       (use-package ox-bibtex)
       (bind-keys :map org-mode-map
         ("RET" . org-return-indent)
         ("M-p"   . outline-previous-visible-heading)
         ("M-n"   . outline-next-visible-heading))

       (plist-put org-format-latex-options :scale 1.5)

       (add-to-list 'org-structure-template-alist
         '("C" "#+BEGIN_COMMENT\n?\n#+END_COMMENT" ""))

       (setq org-latex-packages-alist
         '(("" "minted") ("usenames,dvipsnames,svgnames" "xcolor")))

       (defun my-org-autodone (n-done n-not-done)
         "Switch entry to DONE when all subentries are done, to TODO otherwise."
         (let (org-log-done org-log-states)   ; turn off logging
           (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

       (add-hook 'org-after-todo-statistics-hook 'my-org-autodone)

       (org-babel-do-load-languages
         'org-babel-load-languages
         '((emacs-lisp . t)
            (latex     . t)
            (python    . t)
            ;; FIXME: Make this contingent on ob-ipython
            ;; (ipython   . t)
            (R         . t)
            (octave    . t)
            (matlab    . t)
            (shell     . t)))

       (setq org-confirm-babel-evaluate nil)
       (setq org-export-use-babel t)

       (setq org-latex-minted-options
         '(("linenos" "true")
            ("fontsize" "\\scriptsize")
            ("frame" "lines")))

       (setq org-export-latex-hyperref-format "\\ref{%s}")

       (setq
         org-src-window-setup 'current-window
         org-agenda-window-setup 'current-window)

       (setq org-blank-before-new-entry
         '((heading . true)
            (plain-list-item . auto)))

       (setq
         ;; FIXME: parameter-ize dir `agenda'
         org-default-notes-file "~/agenda/notes.org"

         org-capture-templates
         '(("r" "Reading" entry (file "~/proj/lists/read.org")
             "* TODO %?\n  Entered on %U\n  %i")))

       (setq org-refile-targets '((nil . (:maxlevel . 10))))

       (setq org-export-with-smart-quotes t)

       (use-package toc-org
         :config
         (add-hook 'org-mode-hook 'toc-org-enable)))
   #+END_SRC

** Org-page

   #+BEGIN_SRC emacs-lisp
     (use-package org-page)
   #+END_SRC

** =paradox=

   #+BEGIN_SRC emacs-lisp
     (use-package paradox
       :commands (paradox-list-packages)
       :ensure t
       :init
       (bind-key "p" 'paradox-list-packages jjin-exec-map)
       :config
       (with-eval-after-load 'evil
           (add-to-list 'evil-emacs-state-modes 'paradox-menu-mode))
       (setq paradox-github-token t))

   #+END_SRC

** =pdf-tools=

   #+BEGIN_SRC emacs-lisp
     (use-package pdf-tools
       :mode ("\\.pdf$" . pdf-view-mode)
       :config
       (pdf-tools-install)

       (let ((foreground-orig (car pdf-view-midnight-colors)))
         (setq pdf-view-midnight-colors
               (cons "white" "black")))

       (with-eval-after-load 'evil
           (progn
             (add-to-list 'evil-emacs-state-modes 'pdf-outline-buffer-mode)
             (add-to-list 'evil-emacs-state-modes 'pdf-view-mode))))
   #+END_SRC

** =projectile=

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :ensure t
       :diminish projectile-mode
       :init
       (setq projectile-keymap-prefix (kbd "C-c p")
             projectile-globally-ignored-files '("TAGS"
                                                 "GPATH"
                                                 "GRTAGS"
                                                 "GSYMS"
                                                 "GTAGS")
             projectile-globally-ignored-file-suffixes '("~"))

       :config
       (bind-key "<f12>"
                 (lambda ()
                   "Save all project buffers and compile"
                   (interactive)
                   (projectile-save-project-buffers)
                   (let (compilation-read-command)
                     (projectile-compile-project nil)))
                 projectile-mode-map)

       (bind-key "c"
                 (lambda (arg)
                   "Run `helm-make-projectile' if the package is
     installed and the project contains a Makefile. Otherwise,
     fallback to default, i.e. `projectile-compile-project'."
                   (interactive "P")
                   (if (and (package-installed-p 'helm-make)
                            (file-exists-p (concat (projectile-project-root) "Makefile")))
                       (helm-make-projectile (prefix-numeric-value arg))
                     (projectile-compile-project arg)))
                 projectile-command-map)

       (setq projectile-enable-caching t)

       (with-eval-after-load 'helm
           (setq projectile-completion-system 'helm
                 projectile-switch-project-action 'helm-projectile))

       (projectile-global-mode)

       ;; "disables "mode-line setting by project; extreme hang-up over SSH/Tramp
       (setq projectile-mode-line "Projectile")
       (add-to-list 'projectile-globally-ignored-modes "term-mode")

       (use-package ggtags
         :disabled t
         :config
         (with-eval-after-load 'evil
             (add-to-list 'evil-emacs-state-modes 'ggtags-view-search-history-mode))

         (add-hook 'c-mode-hook 'ggtags-mode)
         (add-hook 'c++-mode-hook 'ggtags-mode)
         (add-hook 'java-mode-hook 'ggtags-mode)))
   #+END_SRC

** =rich-minority-mode=

   #+BEGIN_SRC emacs-lisp
     (use-package rich-minority
       :ensure t
       :config
       (defconst my-rm-excluded-modes
         '(
            " pair"
            " Fill"
            " end"
            " Ace - Window"))
       (dolist (mode my-rm-excluded-modes)
         (add-to-list 'rm-excluded-modes mode)))
   #+END_SRC

** =smart-mode-line=

   #+BEGIN_SRC emacs-lisp
     (use-package smart-mode-line
       :ensure t
       :init
       (setq sml/theme 'respectful)
       :config
       (sml/setup)
       (smart-mode-line-enable))
   #+END_SRC

** =tramp=

   #+BEGIN_SRC emacs-lisp
     (use-package tramp
       :init
       (setq tramp-default-method "ssh")
       (setq password-cache-expiry nil)
       :config

       (add-to-list 'tramp-remote-path "~/bin"))
   #+END_SRC

** =undo-tree=

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :diminish undo-tree-mode
       :bind ("C-<backspace>" . undo-tree-undo))
   #+END_SRC

** =w3m=

   #+BEGIN_SRC emacs-lisp
     (use-package w3m
       :bind (:map jjin-exec-map
                   ("w" . w3m))
       :commands w3m
       :init
       (setq w3m-fill-column 80)

       :config
       (with-eval-after-load 'evil
           (add-to-list 'evil-emacs-state-modes 'w3m-session-select-mode))
       (with-eval-after-load 'ace-link
         (bind-keys :map w3m-mode-map
                    ("o" . ace-link-w3m)))

       (unbind-key "B" w3m-mode-map)
       (bind-keys :map w3m-mode-map
                  ("P" . w3m-view-previous-page)
                  ("n" . w3m-tab-next-buffer)
                  ("p" . w3m-tab-previous-buffer)
                  ("w" . w3m-delete-buffer))

       (use-package w3m-session))
   #+END_SRC

** Language modes

*** Markdown

    #+BEGIN_SRC emacs-lisp
      (use-package markdown-mode
        :mode "\\.md$"
        :init
        (setq markdown-asymmetric-header t)
        :config
        (add-hook 'markdown-mode-hook 'auto-fill-mode)

        (use-package markdown-mode+))
    #+END_SRC

*** YAML

    #+BEGIN_SRC emacs-lisp
      (use-package yaml-mode
        :mode "\\.yaml$")
    #+END_SRC

* (Un)license

  #+BEGIN_SRC text :eval never
    This is free and unencumbered software released into the public domain.

    Anyone is free to copy, modify, publish, use, compile, sell, or
    distribute this software, either in source code form or as a compiled
    binary, for any purpose, commercial or non-commercial, and by any
    means.

    In jurisdictions that recognize copyright laws, the author or authors
    of this software dedicate any and all copyright interest in the
    software to the public domain. We make this dedication for the benefit
    of the public at large and to the detriment of our heirs and
    successors. We intend this dedication to be an overt act of
    relinquishment in perpetuity of all present and future rights to this
    software under copyright law.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
    OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

    For more information, please refer to <http://unlicense.org>
  #+END_SRC

